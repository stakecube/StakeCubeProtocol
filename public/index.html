<html class="main-html" lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SCP Wallet</title>

  <link rel="canonical" href="https://getbootstrap.com/docs/5.0/examples/carousel/">

  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
  <link id="themeSheet" themeIndex="0" href="style/latest-style-light.css" rel="stylesheet">
  <link href="fontawesome/css/fontawesome.min.css" rel="stylesheet">
  <link href="fontawesome/css/all.min.css" rel="stylesheet">
  
  <!-- Functional Libraries (Cryptography, Hashing, Encryption, Encoding, etc) -->
  <script type="text/javascript" src="../scripts/aes-gcm.js"></script>

  <!-- Interface Framework Libraries (GUI, wallet management, networking, etc) -->
  <script type="text/javascript" src="../scripts/qrcode.js"></script>
  <script type="text/javascript" src="../scripts/settings.js"></script>
  <script type="text/javascript" src="../scripts/wallet.js"></script>
  <script type="text/javascript" src="../scripts/network.js"></script>
  <script type="text/javascript" src="js/switchPages.js"></script>

  <!-- SCP LIBRARY GOES BELOW -->
  <script type="text/javascript" src="../src/index.js"></script>
  <!-- SCP LIBRARY GOES ABOVE -->

  <script>window.$ = window.jQuery = require('jquery');</script>
</head>

<body>
  <div id="loginPage" class="page-gradient" style="display: block;">
    <div class="container marketing">
      <div class="verticalalign" style="padding-top: 5%;">
        <div class="vertical-center color-white">
          <center>
            <img id="loginLogo" src="imgs/sc-dark-bg.svg" style="height:50px;">
            <span id="versionLogin" style="position: static;color: white;opacity: 0.325;font-size: small;cursor: default;letter-spacing: 1px;margin-left: 1px;"></span>
            <br><br>
          </center>
          <div class="container">
            <div class="row align-items-center" style="height: 50%;">
              <div class="col-sm-10 offset-sm-1">
                <div class="login-card card-prop2 mb-4">
                  <div class="card-body font-gray">
                    <div class="login-page">
                      <center>
                        <h5 class="mb-3">Unlock your wallet</h5>
                        <br>
                        <div class="omrs-input-group" style="width:100%; margin-bottom:10px;">
                          <label style="display: flex;" class="omrs-input-underlined">
                            <input required id="pass1" type="password" autofocus>
                            <span class="omrs-input-label">Password</span>
                            <button onclick="switchLoginVisibility()" style="background-color: transparent;border-style: none;outline: none;">
                              <i id="pass1Visibility" class="fas fa-eye-slash"></i>
                            </button>
                          </label>
                        </div>
                      </center>

                      <script>
                        'use strict';
                        function switchLoginVisibility() {
                          if (domPass1Visibility.classList.contains("fa-eye-slash")) {
                            // Display pass
                            domPass1Visibility.classList.remove("fa-eye-slash");
                            domPass1Visibility.classList.add("fa-eye");
                            document.getElementById("pass1").setAttribute("type", "text");
                          } else {
                            // Hide pass
                            domPass1Visibility.classList.remove("fa-eye");
                            domPass1Visibility.classList.add("fa-eye-slash");
                            document.getElementById("pass1").setAttribute("type", "password");
                          }
                        }

                        $(document).ready(function(){
                          $('#pass1').keypress(function(e){
                            if(e.keyCode==13) {
                              finishLogin();
                            }
                          });
                        });
                      </script>

                      <table class="mb-0" style="border:0;margin-top:15px;">
                        <tr class="info">
                          <td>
                            <i class="fas fa-info-circle" style="margin-right: 10px;margin-top: 4px;"></i>
                          </td>
                          <td>
                            Please remember to write down your password, if you lose it, StakeCube cannot recover your funds!
                          </td>
                        </tr>
                      </table>

                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    function finishLogin() {
      const nPass = document.getElementById("pass1").value;
      decryptWallet(nPass).then(done => {
        if (done) {
          document.getElementById("pass1").value = "";
          switchToDashboard();
          DB.setWallet(WALLET.toDB()).then(() => {
            if (localStorage.getItem("encwif")) {
              localStorage.removeItem("encwif");
              console.log("DB: Migrated 'encwif' from LS to Backend DB!");
            }
          });
          // Give the cache a kick
          getBlockCount();
          getUnspentTransactions();
          // If an update is available, notify the user after a brief period
          if (isOutdated) {
            setTimeout(() => {
              M.toast({html: '<a style="cursor: pointer;" onclick="openExternalURL(\'https://github.com/stakecube/StakeCubeProtocol/releases/latest\')">An update is available!</a>', displayLength: 30000});
            }, 3 * 1000);
          }
        } else {
          M.toast({html: 'Incorrect Password!', displayLength: 2000});
        }
      });
    }
  </script>

  <header id="guiHeader" style="display: none;">
    <nav class="navbar navbar-expand-md navbar-dark fixed-top navbar-colour font-weight-bold">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">
          <img onclick="switchToDashboard()" src="imgs/sc-dark-bg.svg" style="height:45px;">
          <span id="version" style="position: relative;color: white;opacity: 0.4;font-size: x-small;cursor: default;letter-spacing: 1px;bottom: 3px;"></span>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
          aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <ul class="navbar-nav me-auto mb-2 mb-md-0">
            <li class="nav-item">
              <a class="nav-link active" id="dashboardBtn" aria-current="page" href="#" onclick="switchToDashboard()">
                Dashboard
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="sendBtn" onclick="switchToSend()">
                Send
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="receiveBtn" onclick="switchToReceive()">
                Receive
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="collectionsBtn" onclick="switchToViewCollection();renderNFTs(-1)">
                NFTs
              </a>
            </li>
            <li class="nav-item" id="2faBtnMenu">
              <a class="nav-link" href="#" id="2faBtn" onclick="switchToAuth()">
                2FA
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#" id="createTokenBtn" onclick="switchToCreateToken()">
                Create token
              </a>
            </li>
          </ul>
          <form class="d-flex" style="margin-bottom:0px;">
            <a href="#" onclick="switchToSettings()"><i class="fas fa-cog fas-higher-contrast"></i></a>
          </form>
        </div>
      </div>
    </nav>
  </header>

  <script>
    'use strict';
    // GUI module imports
    const { clipboard } = require('electron');
    const { dialog } = require('electron').remote;
    let authenticator = require("otplib").authenticator;

    // WALLET STATE DATA
    let cachedTokens = [];
    let cachedOwnedNFTs = [];
    let cachedCollections = [];
    let cachedBlockCount = 0;
    let cachedActivity = [];
    let cachedActivityIS = [];
    let cachedCollectionsIS = []; 
    let cachedCoinDeltas = [];

    // Statistical / Informational data
    let valueUSD = 0;
    let currentSupply = 0;

    // Cached DOM elements
    let activityViewSCP = true;
    let domHeader;
    let domLoginPage;
    let domDashboardBtn;
    let domSendBtn;
    let domReceiveBtn;
    let dom2FABtn;
    let dom2FAMenu;
    let domCreateTokenBtn;
    let domScpTokenErrors;
    let domScpTokenName;
    let domScpTokenTicker;
    let domScpTokenSupply;
    let domScpTokenPoSReward;
    let domScpTokenMinAge;
    let domScpCollectionName;
    let domScpCollectionMaxMints;
    let domScpCollectionProtected;
    let domScpTokenDeployBtn;
    let domScpTokenDeployArea;
    let domNFTCollectionsBtn;
    let domNFTBurnBtn;
    let domNFTTransferBtn;
    let domDashboardPage;
    let domSendPage;
    let domReceivePage;
    let domAuthPage;
    let domStakingPage;
    let domSettingsPage;
    let domCreateTokenPage;
    let domCreateNftPage;
    let domScpNftMintBtn;
    let domViewCollection;
    let domCollections;
    let domCollectionsName;
    let domCollectionsList;
    let domViewNFT;
    let domNFTList;
    let domNftDetailTitle;
    let domNftDetailMintCount;
    let domNftDetailImg;
    let domNftDetailID;
    let domNftDetailCollection;
    let domNftDetailImageID;
    let domNftDetailOwner;
    let domNftDetailActivity;
    let domNftDetailActions;
    let domNftMintSubtitle;
    let domNftMintOpts;
    let domNftMintProgress;

    let domPass1Visibility;

    let domReceiveAddress;
    let domBalance;
    let domBalanceUSD;
    let domSendingBalance;
    let domActivityList;
    let domActivitySCC;
    let domActivitySCP;
    let domClaimAllBtn;

    let domMarketcap;
    let domPrice;
    let domBlock;

    let domAuthDisplay;
    let domAuthImport;
    let domAuthTitle;
    let domAuthCode;
    let domAuthTime;
    let domAuthReset;

    let domStakingTitle;
    let domStakingSubtitle;
    let domStakingApy;
    let domStakingRewards;
    let domStakingRedeem;
    let domStakingRoi;

    function getMempoolDeltas(strCurrency) {
      let nDelta = 0;
      if (strCurrency === 'scc') {
        // TODO: Add SCC InstantSend mempool-deltas
      } else {
        const cToken = isFullnode ? TOKENS.getToken(strCurrency) : getCachedToken(strCurrency);
        if (cToken && !cToken.error) {
          for (const cActivity of cachedActivityIS) {
            if (cActivity.token.contract !== cToken.contract) continue;
            if (cActivity.type === 'received' || cActivity.type === 'staked') {
              nDelta += cActivity.amount;
            } else if (cActivity.type === 'sent') {
              nDelta -= cActivity.amount;
            }
          }
        }
      }
      return nDelta;
    }

    function hasMempoolStakes(contract) {
      let fStaked = false;
      const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
      if (cToken && !cToken.error) {
        for (const cActivity of cachedActivityIS) {
          if (cActivity.token.contract !== cToken.contract) continue;
          if (cActivity.type === 'staked') {
            fStaked = true;
          }
        }
      }
      return fStaked;
    }

    function addMockActivity(strType = "unknown", nAmount = 0, cToken) {
      const cActivity = {
          'id': null,
          'token': {
              'contract': cToken.contract,
              'ticker': cToken.ticker,
              'name': cToken.name
          },
          'block': 'Unconfirmed',
          'contract': cToken.contract,
          'account': WALLET.getActiveWallet().getPubkey(),
          'type': strType,
          'amount': nAmount,
      }
      cachedActivityIS.push(cActivity);
    }

    let cachedMempool = [];
    async function getMempoolActivity(account = false, cache = false) {
      if (!cache)
        cachedMempool = isFullnode ? await getFullMempool() : (JSON.parse(await NET.getMempoolLight()));
      const arrActivity = [];
      cachedCollectionsIS = [];
      // Loop all mempool TXs
      for (const cTX of cachedMempool) {
          // Loop all TX vouts
          for (const cVout of cTX.vout) {
              if (!cVout.scriptPubKey) continue;
              if (!cVout.scriptPubKey.hex) continue;
              // Scan the scriptPubKey for OP_RETURN (+ PUSHDATA)
              if (cVout.scriptPubKey.hex.startsWith('6a4c')) {
                  // Found an OP_RETURN! Parse the message from HEX to UTF-8
                  const rawHex = cVout.scriptPubKey.asm.substr(10);
                  const buf = Buffer.from(rawHex, 'hex');
                  const strOp = buf.toString('utf8');
                  if (!strOp.includes(' ')) continue;
                  const arrOp = strOp.split(' ');
                  const isLongData = strOp.length > 64;
                  let isUsingIndex = false;
                  if (UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount)) {
                      isUsingIndex = strOp.startsWith('id');
                      if (isUsingIndex)
                        arrOp[0] = Number(arrOp[0].substr(2));
                  }
                  // Let's check if this is a token deployment or creation
                  if (!isUsingIndex && arrOp[0].startsWith("SCPCREATE")) {
                    // SCP-4 Collections
                    if (arrOp[0].endsWith("4")) {
                      const cColl = new NFT.SCP4(cTX.txid, arrOp[1], Number(arrOp[2]), Number(arrOp[3]), WALLET.getActiveWallet().getPubkey());
                      cColl.totalNFTs = 0;
                      cColl.burnedNFTs = 0;
                      cColl.index = cachedCollections[cachedCollections.length - 1].index + 1 + (cachedCollectionsIS.length ? cachedCollectionsIS.length : 0);
                      cColl.mempool = true;
                      cachedCollectionsIS.push(cColl);
                    }
                  } else {
                    // This may be an SCP-4 NFT action, let's try to find the Collection
                    const cColl = getCachedCollection(arrOp[0]);
                    if (cColl) {
                      // Found the collection, determine the action
                      if (arrOp[1] === 'mint') {
                        // If we don't have this NFT, then add it to the collection cache
                        if (!cColl.nfts || !cColl.nfts.length) cColl.nfts = [];
                        if (!cColl.nfts.find(a => a.id === cTX.txid)) {
                          const cNFT = {
                            'id': cTX.txid,
                            'name': arrOp[2],
                            'imgUrl': arrOp[3],
                            'owner': WALLET.getActiveWallet().getPubkey(),
                            'mempool': true,
                            'activity': [{
                                'tx': cTX.txid,
                                'type': 'mint',
                                'from': null,
                                'to': WALLET.getActiveWallet().getPubkey(),
                                'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed'
                            }]
                          }
                          cColl.nfts.push(cNFT);
                        }
                      } else if (arrOp[1] === 'transfer') {
                        // If we don't have this NFT, try to refresh the collection cache
                        if (!cColl.nfts || !cColl.nfts.length) {
                          cColl.nfts = [];
                          await fetchNFTs(cColl);
                        }
                        const cExistingNFT = cColl.nfts.find(a => a.id === arrOp[3]);
                        if (cExistingNFT) {
                          // NFT exists, so add the activity, if that also doesn't exist!
                          if (!cExistingNFT.activity.find(a => a.tx === cTX.txid)) {
                            cExistingNFT.owner = arrOp[2];
                            cExistingNFT.mempool = true;
                            cExistingNFT.activity.push({
                                'tx': cTX.txid,
                                'type': 'transfer',
                                'from': cTX.vout[1].scriptPubKey.addresses[0],
                                'to': arrOp[2],
                                'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed'
                            });
                          }
                        }
                        if (cExistingNFT && cExistingNFT.owner === WALLET.getActiveWallet().getPubkey()) {
                          const cOwnedNFT = cachedOwnedNFTs.find(a => a.nft === cExistingNFT.id);
                          if (!cOwnedNFT) {
                            const cNewNFT = {
                                'nft': cExistingNFT.id,
                                'name': cExistingNFT.name,
                                'imgUrl': cExistingNFT.imgUrl,
                                'collection': cColl.contract,
                                'collectionIndex': cColl.index,
                                'collectionName': cColl.collectionName,
                                'activity': cExistingNFT.activity
                            }
                            cNewNFT.activity.push({
                                'tx': cTX.txid,
                                'type': 'transfer',
                                'from': cTX.vout[1].scriptPubKey.addresses[0],
                                'to': arrOp[2],
                                'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed'
                            });
                            cachedOwnedNFTs.push(cNewNFT);
                          }
                        }
                      }
                    }
                  }
                  // If one of these flags are enabled, this is highly likely a normal token event
                  if (isFullnode && (isLongData || isUsingIndex)) {
                      // Ensure the token is valid and exists
                      const cToken = isFullnode ? TOKENS.getToken(arrOp[0]) : getCachedToken(arrOp[0]);
                      if (!cToken || cToken.error || cToken.supply <= 0) continue;
                      // Construct the caller's Activity object
                      const cActivity = {
                          'id': cTX.txid,
                          'token': {
                              'contract': cToken.contract,
                              'ticker': cToken.ticker,
                              'name': cToken.name
                          },
                          'block': (cTX.instantlock ? '⚡ C' : 'Unc') + 'onfirmed',
                          'contract': cToken.contract,
                          'account': cTX.vout[1].scriptPubKey.addresses[0],
                          'type': 'unknown',
                          'amount': 0
                      };
                      const cAccount = cActivity.account;
                      // Identify the transaction type
                      const operation = arrOp[1];
                      switch (operation) {
                      case 'mint':
                          cActivity.type = 'received';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      case 'burn':
                          cActivity.type = 'sent';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      case 'send':
                          // Sender activity
                          cActivity.type = 'sent';
                          cActivity.amount = Number(arrOp[2]);
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          // Receiver activity
                          const cRecvActivity = JSON.parse(
                              JSON.stringify(cActivity));
                          cRecvActivity.type = 'received';
                          cRecvActivity.account = arrOp[3];
                          if (!account ||
                                  (account && arrOp[3] === account)) {
                              arrActivity.push(cRecvActivity);
                          }
                          break;

                      case 'redeem':
                          cActivity.type = 'staked';
                          const cStatus = isFullnode ? cToken.getStakingStatus(cToken.getAccount(cAccount)) :
                                                       JSON.parse(await NET.getLightStakingStatus(cToken.contract, cAccount));
                          cActivity.amount = cStatus.unclaimed_rewards;
                          if (!account ||
                                  (account && cAccount === account)) {
                              arrActivity.push(cActivity);
                          }
                          break;

                      default:
                          break;
                      }
                      // End the vout loop
                      break;
                  }
              }
          }
      }
      return arrActivity;
    }

    function getSyncPercentage() {
      // We measure based on our total SCP hash-cache, and our blocks since the start of SCP
      if (cachedBlockCount === 0 || chainHashesCache.length === 0) return 0;
      if (!currentScanBlock || !currentScanBlock.height) return 100;
      return percentOf(nCacheScannedBlks, (cachedBlockCount - nFirstBlock));
    }

    function getBalance(updateGUI = false) {
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      const nBalance = WALLET.getBalance(strPubkey);

      // Update the GUI too, if chosen
      if (updateGUI) {
        // --- Update SCC Balances
        // Set the balance, and adjust font-size for large balance strings
        domBalance.innerText = nBalance.toLocaleString('en-GB', { maximumFractionDigits: 8 });
        if (valueUSD > 0)
          domBalanceUSD.innerText = (nBalance * valueUSD).toFixed(2);
        // And update the Receive page pubkey
        domReceiveAddress.innerText = strPubkey;

        // --- Update SCP token balances
        // Fetch all tokens owned by our account (strPubkey)
        if (isFullnode) {
          cachedTokens = TOKENS.getTokensByAccount(strPubkey);
        } else {
          getTokensByAccountLight(strPubkey);
          fetchNFTsByAddress(strPubkey);
        }
        // Loop all tokens, construct an updated GUI for the Dashboard
        let dashboardTokens = document.getElementById("dashboardTokens");
        let sendTokensSelector = document.getElementById('sendingCoin');
        sendTokensSelector.innerHTML = '<option value="scc" data-thumbnail="imgs/circular-logo.svg">StakeCubeCoin (SCC)</option>';
        dashboardTokens.innerHTML = '';
        if (chainHashesCache.length === 0 && isFullnode) {
          dashboardTokens.innerHTML += '<center style=\'margin-top:30px;\'><p>Loading SCP</p></center>';
        } else if (getSyncPercentage() < 99.99 && isFullnode) {
          dashboardTokens.innerHTML += '<center style=\'margin-top:30px;\'><p id="scpSyncing">SCP is still syncing (' + getSyncPercentage().toFixed(2) + '%)</p></center>';
        } else if (cachedTokens.length > 0) {
          let strDashTokens = "";
          let strSendTokens = "";
          for (const cToken of cachedTokens) {
            let nBal = (getMempoolDeltas(cToken.token.contract) + cToken.account.balance) / COIN;
            if (hideZeroBalance && nBal <= 0) continue;
            let stakingButton = 'onclick="switchToStaking(\'' + cToken.token.contract + '\')"';
            let stakingStyle = 'cursor:pointer;';
            let stakingText = '';
            if (cToken.token.version !== 2) {
              stakingButton = '';
              stakingStyle = '';
            } else {
              let fStaked = hasMempoolStakes(cToken.token.contract);
              if (!fStaked) {
                const nRewards = (cToken.account.unclaimed_balance / COIN);
                // Ensure we have unclaimed stakes, and the token has not hit max supply yet
                if (cToken.account.unclaimed_balance > 0 && (cToken.token.supply + cToken.account.unclaimed_balance) < cToken.token.maxSupply)
                  stakingText = ' <i style="opacity:0.5;">(+' + nRewards.toLocaleString('en-GB', { maximumFractionDigits: (nRewards > 0.1 ? 2 : 8 ) }) + ')</i>';
              } else {
                stakingButton = '';
                stakingStyle = '';
              }
            }
            strDashTokens += '<div class="mt-3 mb-3 font-gray-2 font-weight-bold" style="font-size:15px; max-height: 32px;' + stakingStyle + '" ' + stakingButton + '><img src="imgs/circular-logo.svg" style="width:32px; height:32px; margin-right: 10px"><div class="d-inline-flex flex-column lh-sm" style="position: relative; top: -7px"><span>'+ formatName(cToken.token.ticker, 8) +'</span><span style="opacity: 0.75;font-size:0.75em;">SCP-' + cToken.token.version + '</span></div><span class="float-end theme-color-secondary">' + nBal.toLocaleString('en-GB', { maximumFractionDigits: (nBal > 1 ? 2 : 8) }) + stakingText + '</span></div>';
            strSendTokens += '<option value="scptoken-' + cToken.token.contract + '" data-thumbnail="imgs/circular-logo.svg">' + formatName(cToken.token.name, 10) + ' (' + cToken.token.ticker + ')</option>';
          }
          dashboardTokens.innerHTML += strDashTokens;
          sendTokensSelector.innerHTML += strSendTokens;
        } else {
          dashboardTokens.innerHTML += '<center style=\'margin-top:30px;\'><p>You have no tokens!</p></center>';
        }

        // Update activity widget
        if (isFullnode) {
          if (getSyncPercentage() >= 99.99) {
            cachedActivity = TOKENS.getActivityByAccount(strPubkey).reverse();
            rpcMain.call('getaddressdeltas', {
              'addresses': [strPubkey]
            }).then(res => {
              cachedCoinDeltas = res.reverse();
            }).catch(e => {
              // Fallback incase this node doesn't support address indexing
              getDeltasByAccountLight(strPubkey);
            });
          }
        } else {
          getActivityByAccountLight(strPubkey);
          getDeltasByAccountLight(strPubkey);
        }
        // Fetch SCC Deltas (a list of changes on this address)
        if (!isFullnode || isFullnode && getSyncPercentage() >= 99.99)
          renderActivity();
        // Render the NFT Elements, if the NFTs tab is active
        if (domNFTCollectionsBtn.className.includes('active')) {
          if (isFullnode) {
            renderCollections();
            renderNFTs();
          } else {
            NET.getLightCollectionHeaders().then(collRes => {
              // Add to cache if we don't already have any
              collRes = JSON.parse(collRes);
              collRes.map(addCachedCollection);
              
              renderCollections();
              if (nSelectedCollection !== -1) {
                // Specific contract selected, so load the full NFT supply details of the collection
                fetchNFTs(getCachedCollection(nSelectedCollection));
                renderNFTs();
              } else {
                renderNFTs();
              }
            });
          }
        } else if (!isFullnode) {
          // Just load the lighter data if we're tabbed-out, and don't render
          NET.getLightCollectionHeaders().then(collRes => {
            // Add to cache if we don't already have any
            collRes = JSON.parse(collRes);
            collRes.map(addCachedCollection);
          });
        }
      }

      return nBalance;
    }

    function renderActivity() {
      // Our 'view' is either SCP or SCC, depending on the user's Activity settings
      const arrView = JSON.parse(JSON.stringify(activityViewSCP ? cachedActivity : cachedCoinDeltas));
      let strActivityList = "";
      if (arrView.length > 0) {
        domActivityList.innerHTML = "";
        let arrTxView = [];
        // (SCC view ONLY) Sort the individual output deltas into per-transaction deltas
        if (!activityViewSCP) {
          for (const cDelta of arrView) {
            const cFoundTx = arrTxView.find(a => a.txid === cDelta.txid);
            if (cFoundTx) {
              // Found a prev. TX delta, merge the values
              cFoundTx.satoshis += cDelta.satoshis;
            } else {
              // Didn't find any TX deltas, add a new one (Deep Clone)
              arrTxView.push(JSON.parse(JSON.stringify(cDelta)));
            }
          }
        } else {
          arrTxView = cachedActivityIS.concat(arrView);
        }
        // View SCP or SCC depending on the user's settings
        let i = 0;
        for (const cActivity of arrTxView) {
          if (!activityViewSCP && isScpTx(cActivity.txid)) continue;
          if (limitActivity && i >= 200) break;
          i++;
          const nValue = (cActivity.amount || cActivity.satoshis) / COIN;
          const strTx  = (cActivity.id || cActivity.txid);
          const strBlk = (cActivity.block || cActivity.height).toLocaleString('en-GB');
          const fIsNumBlk = Number.isSafeInteger(cActivity.block || cActivity.height);
          let strType;
          if (activityViewSCP) {
            strType = cActivity.type;
          } else {
            if (cActivity.satoshis >= 0)
              strType = 'received';
            else
              strType = 'sent';
          }
          const strTypeColour = ((strType === 'received' || strType === 'staked') ? "plus" : "minus");
          const strTypeSymbol = ((strType === 'received' || strType === 'staked') ? "+" : "-");
          const strCoinTicker = cActivity.token ? cActivity.token.ticker : 'SCC';
          const strExplorerID = strTx ? 'style="cursor: pointer;" onclick="openExternalURL(\'https://scc.ccore.online/transaction/' + strTx + '\')"' : '';
          strActivityList += '<div class="mt-4 hover-darker" ' + strExplorerID + '><div class="float-start text-center">' + (fIsNumBlk ? 'Block ' : '') + ' ' + strBlk + '</div><span class="float-end ' + strTypeColour + '-balance-color font-weight-bold" style="position:relative; top:11px;"><i style="text-transform: capitalize;padding-right:5px;">' + strType + '</i> ' + strTypeSymbol + Math.abs(nValue).toLocaleString('en-GB', { maximumFractionDigits: nValue > 1 ? 2 : 8, minimumFractionDigits: 2 }) + ' ' + strCoinTicker + '</span></div><br><br><hr style="margin-top:5px; margin-bottom:5px;" class="font-gray">';
        }
        domActivityList.innerHTML += strActivityList;
      } else {
        domActivityList.innerHTML = "<center style='margin-top:30px;'><p>You have no activity!</p></center>";
      }
    }

    let strCollSearch = '';
    function renderCollections(strSearch = strCollSearch) {
      strCollSearch = strSearch;
      // Prep render cache
      let strRendering = '';
      // Get the current Collections source (full-node or lightwallet sources)
      const arrColls = isFullnode ? NFT.getCollectionPtr() : getCachedCollections();
      // Loop all SCP-4-like Collections and append each to the display table
      for (const cColl of arrColls) {
        if (strCollSearch.length && !(cColl.collectionName.toLowerCase().includes(strCollSearch) || cColl.creator.toLowerCase().includes(strCollSearch) || strCollSearch.includes(cColl.contract))) continue;
        // Calculate the supply (All existing NFTs that have not been burned)
        const nCardSupply = isFullnode ?
                              cColl.nfts.filter(a => a.owner !== null).length :
                              cColl.totalNFTs - cColl.burnedNFTs;
        // Calculate if minting additional NFTs is possible
        const fCanMint = (cColl.creator === WALLET.getActiveWallet().getPubkey() && ((cColl.mints < cColl.maxMints) || cColl.maxMints === -1));
        // Construct the render structure
        strRendering += `
                <tr>
                  <td style="cursor:pointer" onclick="switchToViewCollection();renderNFTs(${cColl.index});">${formatName(cColl.collectionName, 40)}</td>
                  <td>${nCardSupply.toLocaleString('en-GB')}</td>
                  <td title="${cColl.maxMints > 0 ? (cColl.maxMints - cColl.burnedNFTs).toLocaleString('en-GB') : "This collection has no NFT cap"}">${cColl.maxMints === -1 ? 'Unlimited' : formatAmount(cColl.maxMints - cColl.burnedNFTs)}</td>
                  <td><span class="subtext">${cColl.protected ? 'Yes' : 'No'}</span></td>
                  <td style="padding-top: 11px;">
                    ${fCanMint ? '<i class="fas fa-plus" style="margin-left: 10px;' + (cColl.mempool ? 'opacity:0.4;' : 'cursor: pointer;') + '" ' + (cColl.mempool ? 'title="Collection is confirming, you can mint once fully confirmed!"' : 'onclick="nSelectedCollection=' + cColl.index + ';switchToNftCreator();"') + '></i>' : ''}
                  </td>
                </tr>`;
      }
      // Draw the cache-constructed HTML
      domCollectionsList.innerHTML = strRendering;
    }

    let nSelectedCollection = -1;
    let strLastNFTRender = '';
    let strLastNftID = '';
    let strLastNftSearch = '';
    async function renderNFTs(nContract, strSearch = strLastNftSearch) {
      if (typeof nContract !== 'number') nContract = nSelectedCollection;
      nSelectedCollection = nContract;
      strLastNftSearch = strSearch;
      // Cache our address and refresh mempool activity
      const strAddr = WALLET.getActiveWallet().getPubkey();
      getMempoolActivity(strAddr, true);
      const domSearchbar = document.getElementById('nftSearch');
      // Prep render cache
      let strRendering = '';
      // Check if we're rendering all our NFTs, or a specific contract's NFTs
      if (nContract === -1) {
        // Set title
        domCollectionsName.innerText = 'My NFTs';
        // Hide the mint button
        domScpNftMintBtn.style.display = 'none';
        // Rendering all owned NFTs
        const arrNFTs = isFullnode ?
                          NFT.getAllNFTsByAccount(strAddr) :
                          cachedOwnedNFTs;
        if (!arrNFTs.length && !isFullnode) (await fetchNFTsByAddress()).map(arrNFTs.push);
        if (arrNFTs.length) {
          for (const cNFT of arrNFTs) {
            if (strLastNftSearch.length && !(cNFT.name.toLowerCase().includes(strLastNftSearch) || strLastNftSearch.includes(cNFT.nft) || strLastNftSearch.includes(cNFT.collection) || strLastNftSearch.includes(cNFT.imgUrl))) continue;
            strRendering += `
              <div class="col-3">
                <div class="card card-prop mb-3 nftCard" style="background: url(https://cloudflare-ipfs.com/ipfs/${cNFT.imgUrl}) no-repeat center;">
                  <div id="nft-${cNFT.nft}" class="card-body refresh-button" onclick="switchToViewNFT('${cNFT.nft}')">
                    <span class="badge nftname" title="${formatName(cNFT.name, 40)}">${formatName(cNFT.name, 26)}</span>
                  </div>
                </div>
              </div>`;
          }
          domSearchbar.style.display = 'block';
        } else {
          strRendering = `
            <center style="margin-top: 17.5vh;">
              <h4>You have no NFTs!</h4>
              <br>
              <button type="button" class="btn btn-theme btn-sm" onclick="switchToReceive()">Receive</button>
              or
              <button type="button" class="btn btn-theme btn-sm" onclick="switchToCreateToken('4')">Create your own</button>
            </center>`;
          domSearchbar.style.display = 'none';
        }
      } else {
        // Rendering NFTs from a contract
        const cColl = isFullnode ? NFT.getCollection(nContract) : getCachedCollection(nContract);
        // Set title
        domCollectionsName.innerText = formatName(cColl.collectionName, 40);
        // Cache the minting status
        const fCanMint = cColl.creator === strAddr && (cColl.maxMints === -1 || cColl.mints < cColl.maxMints);
        // Set the minting button, if eligible
        domScpNftMintBtn.style.display = (fCanMint && !cColl.mempool) ? 'inline-block' : 'none';
        // Ensure we have sufficient cache for more advanced data
        if (!cColl.nfts && !isFullnode) await fetchNFTs(cColl);
        // Construct the render structure
        if (cColl.nfts.length) {
          for (const cNFT of cColl.nfts.filter(a => a.owner !== null)) {
            if (strLastNftSearch.length && !(cNFT.name.toLowerCase().includes(strLastNftSearch) || cNFT.owner.toLowerCase().includes(strLastNftSearch) || strLastNftSearch.includes(cNFT.id) || strLastNftSearch.includes(cNFT.imgUrl))) continue;
            strRendering += `
              <div class="col-3">
                <div class="card card-prop mb-3 nftCard" style="background: url(https://cloudflare-ipfs.com/ipfs/${cNFT.imgUrl}) no-repeat center;${cNFT.owner !== strAddr ? `opacity:0.5;` : ``}">
                  <div id="nft-${cNFT.id}" class="card-body refresh-button" onclick="switchToViewNFT('${cNFT.id}')">
                    <span class="badge nftname" title="${formatName(cNFT.name, 40)}">${formatName(cNFT.name, 20)}</span>
                    ${cNFT.owner === strAddr ? `<i class="far fa-check-circle" style="position:absolute;right:0.75em;top:1.15em;color:#13c372eb!important;" title="You own this NFT!"></i>` : ``}
                  </div>
                </div>
              </div>`;
          }
          domSearchbar.style.display = 'block';
        } else {
          if (fCanMint) {
            strRendering = `
              <center style="margin-top: 17.5vh;">
                <h4>${cColl.mempool ? 'Your collection is confirming!' : 'Your new collection is empty!'}</h4>
                <br>
                ${
                  cColl.mempool ?
                  '<p style="opacity:0.75">Check back in a couple minutes and this collection should be ready for minting!</p>' :
                  '<button type="button" class="btn btn-theme btn-sm" onclick="switchToNftCreator()">Mint the first NFT</button>'
                }
              </center>`;
            domSearchbar.style.display = 'none';
          } else {
            strRendering = `
              <center style="margin-top: 17.5vh;">
                <h4>This collection is empty!</h4>
                <br>
                <p style="opacity:0.75">Check back in a while, maybe the creator will have minted cool stuff!</p>
              </center>`;
            domSearchbar.style.display = 'none';
          }
        }
      }
      // For performance and user sanity: Only render if the structure has changed
      if (strRendering === strLastNFTRender) return scrollToNFT();
      // Draw and cache the cache-constructed HTML
      domNFTList.innerHTML = strRendering;
      strLastNFTRender = strRendering;
      // If we just backed out from an NFT, then scroll to it'd ID, if it exists
      scrollToNFT();
    }

    function scrollToNFT() {
      if (strLastNftID && domViewCollection.style.display === "block") {
        const el = document.getElementById('nft-' + strLastNftID);
        if (el !== null) {
           el.scrollIntoView({behavior: "smooth", block: "center", inline: "nearest"});
           strLastNftID = '';
        }
      }
    }

    async function renderDetailedNFT(strID) {
      const strAddr = WALLET.getActiveWallet().getPubkey();
      // Find the NFT and Collection after refreshing mempool cache
      getMempoolActivity(strAddr, true);
      const cNFT = isFullnode ? NFT.getNFTbyId(strID) : getCachedNFT(strID);
      const cColl = isFullnode ? NFT.getCollection(cNFT.collectionIndex) : (typeof cNFT.collectionIndex === 'number' ? getCachedCollection(cNFT.collectionIndex) : getCachedCollectionByNftID(strID));
      // Refresh the latest cache of this NFT's collection
      const isCached = domNftDetailID.innerText === strID;
      if (isCached) {
        await fetchNFTs(cColl);
      } else {
        fetchNFTs(cColl, strID);
      }
      // Cache the ownership status
      const fOwned = cNFT.owner ? cNFT.owner === strAddr : true;
      // Calculate supply and indexing for displaying
      const nCardSupply = isFullnode ?
                            cColl.nfts.filter(a => a.owner !== null).length :
                            cColl.totalNFTs - cColl.burnedNFTs;
      const nIndex = cColl.nfts ? cColl.nfts.findIndex(a => a.id === strID) : -1;
      // Render all elements
      if (!isCached) {
        domNftDetailTitle.innerText = cNFT.name;
        domNftDetailImg.src = 'https://cloudflare-ipfs.com/ipfs/' + cNFT.imgUrl;
        domNftDetailID.innerText = cNFT.nft || cNFT.id;
        domNftDetailCollection.setAttribute('onclick', 'switchToViewCollection();renderNFTs(' + cColl.index + ');');
        domNftDetailImageID.innerText = cNFT.imgUrl;
      }
      domNftDetailMintCount.innerHTML = '<b>#' + (nIndex === -1 ? '?' : (nIndex + 1)) + '</b><b style="opacity: 0.75">/' + (cColl.maxMints > 0 ? (cColl.maxMints - cColl.burnedNFTs) : nCardSupply) + '</b>';
      domNftDetailOwner.innerText = cNFT.owner || strAddr;
      strLastNftID = cNFT.nft || cNFT.id;
      // Pre-render activity
      let strRendering = '';
      // Deep-clone and reverse the activity list
      const arrActivity = JSON.parse(JSON.stringify(cNFT.activity)).reverse();
      for (const cActivity of arrActivity) {
        strRendering += `
          <tr>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.tx}', 'Transaction ID')">${formatName(cActivity.tx, 6)}</td>
            <td><span onclick="copyToClipboard('${cActivity.type}', 'Type')" class="badge hover-darker" style="background-color:#c36666;text-transform:capitalize;cursor:pointer;">${cActivity.type}</span></td>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.from}', 'Sender Address')">${cActivity.from !== null ? formatName(cActivity.from, 6) : 'Mint'}</td>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.to}', 'Receive Address')">${cActivity.to !== null ? formatName(cActivity.to, 6) : 'Burn'}</td>
            <td style="cursor:pointer" class="hover-darker" onclick="copyToClipboard('${cActivity.block}', 'Block Height')">${cActivity.block.toLocaleString('en-GB')}</td>
          </tr>`;
      }
      // Render the details page
      domNftDetailActivity.innerHTML = strRendering;
      // Render the action buttons, if owned by us
      domNftDetailActions.style.display = fOwned ? 'block' : 'none';
      if (cNFT.mempool) {
        domNFTTransferBtn.style.opacity = 0.4;
        domNFTTransferBtn.style.cursor = 'default';
        domNFTTransferBtn.setAttribute('data-bs-toggle', '');
        domNFTTransferBtn.setAttribute('title', 'This NFT is confirming, it cannot be transfered yet!');
      } else {
        domNFTTransferBtn.style.opacity = 1;
        domNFTTransferBtn.style.cursor = 'pointer';
        domNFTTransferBtn.setAttribute('data-bs-toggle', 'modal');
        domNFTTransferBtn.setAttribute('title', 'Transfer your NFT to someone else');
      }
      // Gray-out the 'burn' button if this collection is protected
      if (fOwned && cColl.protected) {
        domNFTBurnBtn.style.opacity = 0.4;
        domNFTBurnBtn.style.cursor = 'default';
        domNFTBurnBtn.setAttribute('data-bs-toggle', '');
        domNFTBurnBtn.setAttribute('title', 'This NFT is protected, it cannot be burned!');
      } else if (fOwned) {
        if (cNFT.mempool) {
          // NFT is owned, but confirming
          domNFTBurnBtn.style.opacity = 0.4;
          domNFTBurnBtn.style.cursor = 'default';
          domNFTBurnBtn.setAttribute('data-bs-toggle', '');
          domNFTBurnBtn.setAttribute('title', 'This NFT is confirming, it cannot be burned yet!');
        } else {
          // NFT is owned and confirmed
          domNFTBurnBtn.style.opacity = 1;
          domNFTBurnBtn.style.cursor = 'pointer';
          domNFTBurnBtn.setAttribute('data-bs-toggle', 'modal');
          domNFTBurnBtn.setAttribute('title', 'Burn (destroy) your NFT');
        }
      } else {
        // NFT is not owned
        domNFTBurnBtn.style.opacity = 0.4;
        domNFTBurnBtn.style.cursor = 'default';
        domNFTBurnBtn.setAttribute('data-bs-toggle', '');
        domNFTBurnBtn.setAttribute('title', '');
      }
      // Select the NFT
      cSelectedNFT = getCachedNFT(cNFT.id || cNFT.nft, true);
    }

    function setActivityView(viewSCP) {
      activityViewSCP = viewSCP;
      domActivitySCC.style.opacity = viewSCP ? 0.4 : 1;
      domActivitySCP.style.opacity = viewSCP ? 1 : 0.4;
      domActivitySCC.style.cursor  = viewSCP ? 'pointer' : 'default';
      domActivitySCP.style.cursor  = viewSCP ? 'default' : 'pointer';
      renderActivity();
    }

    function getCachedToken(query) {
      const cToken = cachedTokens.find(a => a.token.contract === query);
      return typeof cToken !== 'undefined' ? cToken.token : false;
    }

    function getCachedAccount(ctoken) {
      const cToken = cachedTokens.find(a => a.token.contract === ctoken.contract);
      return typeof cToken !== 'undefined' ? cToken.account : false;
    }

    function getCachedCollection(query) {
      const cColl = getCachedCollections().find(a => a.contract === query || a.index === query);
      return cColl || false;
    }
    function getCachedCollections() {
      return cachedCollections.concat(cachedCollectionsIS);
    }
    
    function addCachedCollection(cNewColl) {
      // Try to find an existing one
      const cColl = getCachedCollection(cNewColl.contract);
      if (!cColl) {
        cachedCollections.push(cNewColl);
      } else {
        // Copy most data over from the new collection
        for (const key of Object.keys(cNewColl)) {
          cColl[key] = cNewColl[key];
        }
      }
      return true;
    }

    function getCachedCollectionByNftID(strID) {
      for (const cColl of getCachedCollections()) {
        const cNFT = (cColl.nfts && cColl.nfts.length) ? cColl.nfts.find(a => a.id === strID) : false;
        if (cNFT) return cColl;
      }
      return false;
    }

    function getCachedNFT(query, mine = false) {
      let cNFT;
      // First, we'll scan all other known NFTs for a match
      if (!mine) {
        for (const cColl of getCachedCollections()) {
          if (cColl.nfts && cColl.nfts.length) {
            cNFT = cColl.nfts.find(a => a.id === query);
            if (cNFT) break;
          }
        }
      }
      if (!cNFT) {
        // If not, check if the query matches a self-owned NFT
        cNFT = cachedOwnedNFTs.find(a => a.nft === query);
      }
      return cNFT;
    }

    function isScpTx(strTx) {
      return cachedActivity.findIndex(a => a.id === strTx) !== -1 || // SCP(1-2) transactions
             cachedOwnedNFTs.findIndex(a => a.nft === strTx) !== -1; // SCP-4 NFT deployments
    }

    async function fetchNFTs(cColl, renderID = null) {
      // Sync NFTs from the lightwallet server
      const cCollRes = JSON.parse(await NET.getLightCollection(cColl.contract));
      if (!cCollRes.error)
        addCachedCollection(cCollRes);
      if (renderID !== null)
        renderDetailedNFT(renderID);
      return getCachedCollection(cColl.index);
    }

    async function fetchNFTsByAddress(strAddr = WALLET.getActiveWallet().getPubkey()) {
      // Sync addr-specific NFTs from the lightwallet server
      const arrNFTsRes = JSON.parse(await NET.getLightNFTsByAccount(strAddr));
      if (!arrNFTsRes.error)
        cachedOwnedNFTs = arrNFTsRes;
      return cachedOwnedNFTs;
    }

    function sendTransactionGUI() {
      const coinSelection = document.getElementById("sendingCoinVal").value;
      const sendAmount = Number(document.getElementById("sendAmount").value.trim());
      const sendAddress = document.getElementById("sendAddress").value.trim();
      if (!sendAmount || !Number.isFinite(sendAmount)) {
        return M.toast({html: 'Please enter a valid amount!', displayLength: 2000});
      }
      if (!sendAddress || sendAddress.length !== 34 || !sendAddress.startsWith("s")) {
        return M.toast({html: 'Please enter a valid address!', displayLength: 2000});
      }
      const strAddr = WALLET.getActiveWallet().getPubkey();
      const strPrivkey = WALLET.getActiveWallet().getPrivkey();
      if (coinSelection === "scc") {
        console.log("Constructing TX of value: " + sendAmount + " SCC");
        const cTx = WALLET.sccjs.tx.transaction();
        // Inputs
        const usedUTXOs = WALLET.getCoinsToSpend(sendAmount * COIN, false, strAddr);
        const nUTXOs = usedUTXOs.reduce((a, b) => {return a + b.sats}, 0);
        for (const cUTXO of usedUTXOs)
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        if (sendAmount >= nUTXOs / COIN) return M.toast({html: 'Not enough funds!', displayLength: 2000});
        // Destination output
        cTx.addoutput(sendAddress, sendAmount);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nSpent = (nFee + sendAmount).toFixed(8);
        const nChange = ((nUTXOs / COIN) - nSpent).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(strPrivkey, 1).then(strSignedTx => {
          sendTransaction(strSignedTx, usedUTXOs);
        });
      } else {
        const strToken = coinSelection.substr(9);
        const cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        const cAccount = isFullnode ? cToken.getAccount(strAddr) : getCachedAccount(cToken);
        const nBal = getMempoolDeltas(cToken.contract) + cAccount.balance;
        if ((nBal / COIN) < sendAmount) return M.toast({html: 'You don\'t have enough ' + cToken.ticker + '!', displayLength: 3000});
        console.log("Constructing SCP-" + cToken.version + " Transfer TX for: " + sendAmount + " " + formatName(cToken.name, 12) + " (" + cToken.contract + ")");
        const cTx = WALLET.sccjs.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(10000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? "id" + cToken.index : cToken.contract;
        cTx.addoutputburn(0.00000001, idContract + " send " + Math.round(sendAmount * COIN) + " " + sendAddress);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(strPrivkey, 1).then(strSignedTx => {
          addMockActivity("sent", sendAmount * COIN, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            M.toast({html: 'Transaction Sent!', displayLength: 1250});
            // Reset inputs
            document.getElementById("sendAmount").value = "";
            document.getElementById("sendAddress").value = "";
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
          });
        });
      }
    }

    function claimStakingRewards(contract) {
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        const cAccount = isFullnode ? cToken.getAccount(strAddr) : getCachedAccount(cToken);
        console.log("Constructing SCP-" + cToken.version + " stake claim TX for " + (cAccount.unclaimed_balance / COIN).toLocaleString('en-GB') + " " + formatName(cToken.name, 12) + " (" + cToken.contract + ")");
        // Disable claim button
        domStakingRedeem.setAttribute('onclick', '');
        domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'Redeeming...';
        // Contruct SCP transaction
        const cTx = WALLET.sccjs.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? "id" + cToken.index : cToken.contract;
        cTx.addoutputburn(0.00000001, idContract + " redeem");
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          addMockActivity("staked", cAccount.unclaimed_balance, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
          });
        });
    }

    let isClaiming = false;
    async function claimAll() {
      if (isClaiming) return;
      isClaiming = true;
      let nClaims = 0;
      const cWallet = WALLET.getActiveWallet();
      for (const cToken of cachedTokens) {
          if (cToken.token.version !== 2) continue;
          if (cToken.account.unclaimed_balance <= 0) continue;
          if (hasMempoolStakes(cToken.token.contract)) continue;
          // Let's claim the rewards!
          domClaimAllBtn.style.opacity = 0.4;
          domClaimAllBtn.style.cursor = "default";
          domClaimAllBtn.innerText = "Claiming " + cToken.token.ticker;
          // Init wallet & TX constructor
          const cTx = WALLET.sccjs.tx.transaction();
          // Asynchronously sync UTXOs with the network
          await WALLET.refreshUTXOs(cWallet.getPubkey());
          // Add input
          const cUTXO = WALLET.getCoinsToSpend(2000, true, cWallet.getPubkey())[0];
          if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
          // SCP output
          const fIndexed = UPGRADES.isTokenIndexingActive(isFullnodePtr() ? nCacheHeight : cachedBlockCount);
          const idContract = fIndexed ? "id" + cToken.token.index : cToken.token.contract;
          cTx.addoutputburn(0.00000001, idContract + " redeem");
          // Fee & Change output
          const nFee = WALLET.getFee(cTx.serialize().length);
          const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
          cTx.addoutput(cWallet.getPubkey(), nChange);
          // Sign & Broadcast
          const strSignedTx = await cTx.sign(cWallet.getPrivkey(), 1);
          addMockActivity("staked", cToken.account.unclaimed_balance, cToken.token);
          await WALLET.broadcastTx(strSignedTx);
          nClaims++;
          // Mark UTXO as spent
          cUTXO.spent = true;
          // If no available UTXOs: Sleep to allow the mempool time to return our fresh UTXO set
          if (!WALLET.getAvailableUTXOs(cWallet.getPubkey()).length)
            await sleep(500);
        }
        await sleep(500);
        // Refresh the final UTXO set after a small sleep
        await WALLET.refreshUTXOs(cWallet.getPubkey());
        // Reset Claim All button
        domClaimAllBtn.innerText = "Claim All";
        domClaimAllBtn.style.cursor = "pointer";
        domClaimAllBtn.style.display = "none";
        domClaimAllBtn.style.opacity = 1;
        isClaiming = false;
        // Pull mempool transactions
        if (isFullnodePtr()) {
          cachedActivityIS = await getMempoolActivity(cWallet.getPubkey());
        } else {
          const strRes = await NET.getMempoolActivityLight(cWallet.getPubkey());
          cachedActivityIS = JSON.parse(strRes);
        }
        isClaiming = false;
        // Notify the user, finished!
        return M.toast({html: 'Redeemed ' + nClaims + ' rewards!', displayLength: 5000});
    }

    function deploySCP(version = 1, params = []) {
        if (!Number.isSafeInteger(version)) return console.error("SCP token must have a version integer!");
        if (params.length < 1) return console.error("SCP token deployment requires params!\nE.g; deploySCP(1, ['CatCoin', 'CAT', " + COIN + "])");
        // Ensure SCP params look atleast somewhat sane
        for (const param of params) {
          if (typeof param === 'string') {
            if (param.length === 0)  return M.toast({html: 'No empty strings allowed!', displayLength: 3000});
            if (param.length > 100)  return M.toast({html: 'No strings over 100 chars allowed!', displayLength: 4000});
            if (param.includes(' ')) return M.toast({html: 'No spaces allowed in SCP strings!', displayLength: 4000});
          } else
          if (typeof param === 'number') {
            // No floats allowed
            if (!Number.isInteger(param))    return M.toast({html: 'No floats allowed! Please use integers\nRef: ' + param, displayLength: 4000});
            // No integers larger than the safe integer 
            if (!Number.isSafeInteger(param)) return M.toast({html: 'An integer is too large, unsafe to deploy!\nRef: ' + ((param / COIN) / 1000000) + " mil", displayLength: 4000});
          } else {
            return M.toast({html: 'Unsupported param detected: ' + typeof param, displayLength: 3000});
          }
        }
        console.log("Constructing SCP-" + version + " deployment TX");
        const cTx = WALLET.sccjs.tx.transaction();
        // Inputs
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const nDeployCost = (nDeployFee * COIN) + 1000;
        const usedUTXOs = WALLET.getCoinsToSpend(nDeployCost, false, strAddr);
        const nUTXOs = usedUTXOs.reduce((a, b) => {return a + b.sats}, 0);
        for (const cUTXO of usedUTXOs)
          cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        if (nDeployCost >= nUTXOs) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        // SCP output
        cTx.addoutputburn(0.00000001, "SCPCREATE" + version + " " + params.join(" "));
        // Static Deployment fee (Sent to the SCC burn address)
        cTx.addoutput(strDeployFeeDest, nDeployFee);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nSpent = (nFee + nDeployFee).toFixed(8);
        const nChange = ((nUTXOs / COIN) - nSpent).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          WALLET.broadcastTx(strSignedTx).then(strTX => {
            usedUTXOs.forEach(cUTXO => { cUTXO.spent = true; });
            // Updates NFTs and other contracts
            getMempoolActivity(strAddr).then(res => {
              if (version === 4) {
                switchToCollections();
                window.scrollTo(0, document.body.scrollHeight);
              }
            });
          });
        });
    }

    function mintSCP(contract, amount) {
        console.log("Constructing SCP mint TX for " + (amount / COIN).toLocaleString('en-GB'));
        const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const cTx = WALLET.sccjs.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(10000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        cTx.addoutputburn(0.00000001, contract + " mint " + amount);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          if (cToken && !cToken.error)
            addMockActivity("received", amount, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
            M.toast({html: 'Minting ' + (amount / COIN).toLocaleString('en-GB') + ' tokens!', displayLength: 3000});
          });
        });
    }

    function burnSCP(contract, amount) {
        console.log("Constructing SCP burn TX for " + (amount / COIN).toLocaleString('en-GB'));
        // Use our first UTXO, as the fees will be incredibly low anyway
        const cToken = isFullnode ? TOKENS.getToken(contract) : getCachedToken(contract);
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const cTx = WALLET.sccjs.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(10000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        cTx.addoutputburn(0.00000001, contract + " burn " + amount);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          if (cToken && !cToken.error)
            addMockActivity("sent", amount, cToken);
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            cUTXO.spent = true;
            if (isFullnodePtr()) {
              getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
            } else {
              NET.getMempoolActivityLight(strAddr).then(strRes => {
                cachedActivityIS = JSON.parse(strRes);
              });
              getUnspentTransactions();
            }
            M.toast({html: 'Burning ' + (amount / COIN).toLocaleString('en-GB') + ' tokens!', displayLength: 3000});
          });
        });
    }

    function autofillSendingAmount() {
      document.getElementById("sendAmount").value = domSendingBalance.innerText.replace(/,/g, '');
    }

    function refreshSendBalance() {
      // Update available balance display
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      let nSendBalanceDisplay = 0;
      const strCurrency = document.getElementById("sendingCoinVal").value;
      if (strCurrency === "scc") {
        nSendBalanceDisplay = WALLET.getBalance(strPubkey);
      } else {
        const strToken = strCurrency.substr(9);
        const cToken = isFullnode ? TOKENS.getToken(strToken) : getCachedToken(strToken);
        const cAccount = isFullnode ? cToken.getAccount(strPubkey) : getCachedAccount(cToken);
        const nBal = getMempoolDeltas(cToken.contract) + cAccount.balance;
        nSendBalanceDisplay = nBal / COIN;
      }
      domSendingBalance.innerText = nSendBalanceDisplay.toLocaleString('en-GB', { maximumFractionDigits: 8 });
    }

    function refreshSyncStatus() {
      let domScpSyncing = document.getElementById("scpSyncing");
      const syncPercent = getSyncPercentage();
      if (syncPercent > 99.99) {
        // Sync is close enough to being finished, stop checking and load the tokens!
        clearInterval(syncStatusInterval);
        getBalance(true);
      }
      if (domScpSyncing) {
        domScpSyncing.innerText = 'SCP is still syncing (' + syncPercent.toFixed(2) + '%)';
      } else if (syncPercent > 0) {
        getBalance(true);
      }
    }

    let currentStakingToken = false;
    let guiStakingToken;
    let guiStakingAccount;
    let guiStakingStatus;
    function refreshStakingStatus(contract) {
      const strPubkey = WALLET.getActiveWallet().getPubkey();
      if (isFullnode) {
        guiStakingToken   = TOKENS.getToken(contract);
        guiStakingAccount = guiStakingToken.getAccount(strPubkey);
        guiStakingStatus  = guiStakingToken.getStakingStatus(guiStakingAccount);
      } else {
        guiStakingToken   = getCachedToken(contract);
        guiStakingAccount = getCachedAccount(guiStakingToken);
        getStakingStatusLight(contract, strPubkey);
      }
      // Put token + account info on the Staking Page on this refresh!
      if ((guiStakingToken && guiStakingAccount && guiStakingStatus) && guiStakingStatus.enabled) {
        domStakingTitle.innerText = formatName(guiStakingToken.name, 18) + " (" + formatName(guiStakingToken.ticker, 6) + ")";
        // Run a quick'n'dirty APY calculation based on the current weight reward
        const nReward = guiStakingToken.inflation * guiStakingStatus.weight;
        const nTotalRewards = guiStakingAccount.unclaimed_balance / COIN;
        // Also check to ensure we haven't hit the max supply yet
        if (guiStakingToken.supply === guiStakingToken.maxSupply ||
           (guiStakingToken.supply + guiStakingAccount.unclaimed_balance) >= guiStakingToken.maxSupply)
        {
          domStakingApy.innerText = "0%";
          domStakingRoi.innerText = "";
          domStakingSubtitle.innerText = formatName(guiStakingToken.name, 12) + " has hit it's max supply of " + (guiStakingToken.maxSupply / COIN).toLocaleString('en-GB', { maximumFractionDigits: 8 }) + " " + formatName(guiStakingToken.ticker, 6)  + "!";
          domStakingRewards.innerText = "Cap Reached";
          domStakingRedeem.setAttribute('onclick', '');
          if (!domStakingRedeem.classList.contains('disabled'))
            domStakingRedeem.classList.add('disabled');
          domStakingRedeem.innerText = 'No Stakes to Claim';
        } else {
          const fStaked = hasMempoolStakes(guiStakingToken.contract);
          const nAPY = percentOf((nReward * 720) * 365, guiStakingAccount.balance);
          if (nAPY > 0.01 && nReward > 1) {
            domStakingApy.innerText = nAPY.toLocaleString('en-GB', { maximumFractionDigits: (nAPY > 100 ? 0 : 2) }) + "%";
            domStakingRoi.innerText = "or a ROI of " + percentOf(guiStakingAccount.unclaimed_balance, guiStakingAccount.balance).toLocaleString('en-GB', { maximumFractionDigits: 2 }) + "%";
          } else {
            domStakingApy.innerText = "---";
            domStakingRoi.innerText = "";
          }
          domStakingSubtitle.innerText = "You've been staking for " + (guiStakingStatus.age - guiStakingToken.minAge).toLocaleString('en-GB') + " blocks and earned...";
          if (fStaked) {
            domStakingRewards.innerText = '0 ' + formatName(guiStakingToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          } else if (guiStakingAccount.unclaimed_balance > 0) {
            domStakingRewards.innerText = nTotalRewards.toLocaleString('en-GB', { maximumFractionDigits: nTotalRewards > 1 ? 4 : 8}) + " " + formatName(guiStakingToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', 'claimStakingRewards("' + contract + '")');
            domStakingRedeem.classList.remove('disabled');
            domStakingRedeem.innerText = 'Claim Rewards';
          } else {
            domStakingRewards.innerText = '0 ' + formatName(guiStakingToken.ticker, 6);
            domStakingRedeem.setAttribute('onclick', '');
            if (!domStakingRedeem.classList.contains('disabled'))
              domStakingRedeem.classList.add('disabled');
            domStakingRedeem.innerText = 'No Stakes to Claim';
          }
        }
      } else if (guiStakingToken && guiStakingAccount && guiStakingStatus) {
        domStakingTitle.innerText = formatName(guiStakingToken.name, 18) + " (" + formatName(guiStakingToken.ticker, 6) + ")";
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerText = "Your tokens need another " + (guiStakingToken.minAge - guiStakingStatus.age).toLocaleString('en-GB') + " blocks to mature before earning stakes!";
        domStakingRewards.innerText = nTotalRewards.toLocaleString('en-GB', { maximumFractionDigits: nTotalRewards > 1 ? 4 : 8 }) + " " + guiStakingToken.ticker;
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      } else {
        domStakingTitle.innerText = guiStakingToken ? formatName(guiStakingToken.name, 18) + " (" + formatName(guiStakingToken.ticker, 6) + ")" : "Loading...";
        domStakingApy.innerText = "---";
        domStakingRoi.innerText = "";
        domStakingSubtitle.innerText = "Loading...";
        domStakingRewards.innerText = "...";
        domStakingRedeem.setAttribute('onclick', '');
        if (!domStakingRedeem.classList.contains('disabled'))
          domStakingRedeem.classList.add('disabled');
        domStakingRedeem.innerText = 'No Stakes to Claim';
      }
    }

    function import2FA() {
      const strNewSecret = document.getElementById("authSecretImport").value;
      const testToken = authenticator.generate(strNewSecret);
      if (testToken && testToken.toString().length === 6) {
        WALLET.set2FAkey(strNewSecret);
        DB.setWallet(WALLET.toDB());
      }
    }

    function remove2FA() {
      WALLET.set2FAkey("");
      DB.setWallet(WALLET.toDB());
      refreshAuthenticator();
    }

    let lastAuthCode = null;
    function refreshAuthenticator() {
      const checkForSecret = localStorage.getItem("authsecret");
      if (checkForSecret) {
        WALLET.set2FAkey(checkForSecret);
        localStorage.removeItem("authsecret");
        console.log("DB: Migrated 2FA LS to Backend DB!");
        DB.setWallet(WALLET.toDB());
      }
      const strSecret = WALLET.get2FAkey();
      if (!strSecret) {
        // No authentication linked
        domAuthImport.style.display = "";
        domAuthDisplay.style.display = "none";
        domAuthTitle.innerText = "Setup your 2FA";
        domAuthReset.style.display = "none";
      } else {
        // Auth code already imported
        domAuthImport.style.display = "none";
        domAuthDisplay.style.display = "";
        domAuthTitle.innerText = "Login using 2FA";
        domAuthReset.style.display = "";
        // Fetch the current code
        const authCode = authenticator.generate(strSecret);
        if (lastAuthCode !== authCode)
          domAuthCode.innerText = authCode;
        const authTimeRemaining = authenticator.timeRemaining()
        domAuthTime.innerText = authTimeRemaining + " second" + (authTimeRemaining === 1 ? "" : "s") + " remaining until next code";
        lastAuthCode = authCode;
      }

      // Also use this chance to update the Staking page, if it's open
      if (domStakingPage.style.display === "block" && currentStakingToken) {
        refreshStakingStatus(currentStakingToken);
      }

      // Also use this to update the Claim All button's visibility
      if ((!isFullnode && cachedTokens.length) || getSyncPercentage() >= 99.99) {
        let nPendingStakes = 0;
        for (const cToken of cachedTokens) {
          if (cToken.token.version !== 2) continue;
          if (cToken.account.unclaimed_balance <= 0) continue;
          if (hasMempoolStakes(cToken.token.contract)) continue;
          nPendingStakes++;
        }
        if (nPendingStakes > 1) {
          domClaimAllBtn.style.display = "inline-block";
        } else if (domClaimAllBtn.style.display !== "none") {
          domClaimAllBtn.style.display = "none";
        }
      }
    }

    function copyToClipboard(text, name) {
      clipboard.writeText(text);
      M.toast({html: name + ' copied to Clipboard!', displayLength: 2000});
    }

    function openExternalURL(url) {
      require("electron").shell.openExternal(url);
    }

    function showFileInExplorer(path) {
      require("electron").shell.showItemInFolder(path);
    }

    function formatName(name, limit) {
      return (name.length > limit ? name.substr(0, limit) + "…" : name).trim();
    }

    function formatAmount(n) {
      if      (n >= 1000000000000000) return (n / 1000000000000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "Q";
      else if (n >= 1000000000000) return (n / 1000000000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "T";
      else if (n >= 1000000000) return (n / 1000000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "B";
      else if (n >= 1000000) return (n / 1000000).toLocaleString('en-GB', {maximumFractionDigits: 2}) + "M";
      else return n.toLocaleString('en-GB', {maximumFractionDigits: 8});
    }

    function percentOf(partial, full) {
      return (partial / full) * 100;
    }

    function percentChange(decrease, oldNumber) {
      return (decrease / oldNumber) * 100;
    }

    const sleep = (milliseconds) => {
      return new Promise(resolve => setTimeout(resolve, milliseconds));
    }

    setInterval(() => {
      // Check block count + UTXO sync every 10 seconds
      getBlockCount();
      const strAddr = WALLET.getActiveWallet().getPubkey();
      if (strAddr) {
        getUnspentTransactions();
        if (!isFullnodePtr()) {
          // Fetches SCP-1 and SCP-2 activity
          NET.getMempoolActivityLight(strAddr).then(strRes => {
            cachedActivityIS = JSON.parse(strRes);
          });
          // Updates NFTs and other contracts
          if (domViewNFT.style.display === "block") {
            getMempoolActivity(strAddr).then(res => {
              renderDetailedNFT(domNftDetailID.innerText);
            });
          }
        }
      }
      // Update Dashboard stats
      if (valueUSD > 0) {
        domBalanceUSD.innerText = (getBalance() * valueUSD).toFixed(2);
        domPrice.innerText = "$" + valueUSD.toFixed(2);
        if (currentSupply > 0)
          domMarketcap.innerText = "$" + (currentSupply * valueUSD).toLocaleString('en-GB', { maximumFractionDigits: 0});
      }
      // Fetch price and supply info
      getCoinValue();
      getCoinSupply();
    }, 10000);

    // Refresh syncing status
    let syncStatusInterval = setInterval(refreshSyncStatus, 200);

    // Refresh 2FA system
    setInterval(refreshAuthenticator, 1000);

    onload = () => {
      // Cache all our UI elements
      domTheme = document.getElementById("themeSheet");
      domThemeButton = document.getElementById("themeButton");
      // Initialize theme from disk
      loadTheme();
      domHeader = document.getElementById("guiHeader");
      domLoginPage = document.getElementById("loginPage");
      domPass1Visibility = document.getElementById("pass1Visibility");
      domDashboardPage = document.getElementById('dashboardPage');
      domSendPage = document.getElementById('sendPage');
      domReceivePage = document.getElementById('receivePage');
      domAuthPage = document.getElementById('authPage');
      domStakingPage = document.getElementById('stakingPage');
      domSettingsPage = document.getElementById('settingsPage');
      domCreateTokenPage = document.getElementById('createTokenPage');
      domCreateNftPage = document.getElementById('createNftPage');
      domScpNftMintBtn = document.getElementById('scpNftMintBtn');
      domViewCollection = document.getElementById('viewCollection');
      domCollections = document.getElementById('NFTCollections');
      domCollectionsName = document.getElementById('collectionName');
      domCollectionsList = document.getElementById('collectionsList');
      domViewNFT = document.getElementById('viewNFT');
      domNFTList = document.getElementById('nftList');
      domAuthDisplay = document.getElementById('authDisplay');
      domAuthImport = document.getElementById('authImport');
      domAuthTitle = document.getElementById('authTitle');
      domReceiveAddress = document.getElementById("receiveAddress");
      domAuthCode = document.getElementById("authCode");
      domAuthTime = document.getElementById("authTime");
      domAuthReset = document.getElementById("authReset");
      domBalance = document.getElementById("guiBalance");
      domBalanceUSD = document.getElementById("balanceUSD");
      domSendingBalance = document.getElementById("sendingCoinBalance");
      domPrice = document.getElementById("dashboardPrice");
      domMarketcap = document.getElementById("dashboardMarketcap");
      domBlock = document.getElementById("dashboardBlock");
      domDashboardBtn = document.getElementById("dashboardBtn");
      domActivityList = document.getElementById("activityList");
      domActivitySCC = document.getElementById("domActivitySCC");
      domActivitySCP = document.getElementById("domActivitySCP");
      domClaimAllBtn = document.getElementById("domClaimAllBtn");
      domScpTokenDeployArea = document.getElementById('scpTokenDeployArea');
      domNFTBurnBtn = document.getElementById('nftBurnBtn');
      domNFTTransferBtn = document.getElementById('nftTransferBtn');
      domSendBtn = document.getElementById("sendBtn");
      domReceiveBtn = document.getElementById("receiveBtn");
      dom2FABtn = document.getElementById("2faBtn");
      domCreateTokenBtn = document.getElementById("createTokenBtn");
      domScpTokenErrors = document.getElementById("scpTokenErrors");
      domScpTokenName = document.getElementById("scpTokenName");
      domScpTokenTicker = document.getElementById("scpTokenTicker");
      domScpTokenSupply = document.getElementById("scpTokenSupply");
      domScpTokenPoSReward = document.getElementById("scpTokenPoSReward");
      domScpTokenMinAge = document.getElementById("scpTokenMinAge");
      domScpCollectionName = document.getElementById('scpCollectionName');
      domScpCollectionMaxMints = document.getElementById('scpCollectionMaxMints');
      domScpCollectionProtected = document.getElementById('scpCollectionProtected');
      domScpTokenDeployBtn = document.getElementById("scpTokenDeployBtn");
      domNFTCollectionsBtn = document.getElementById("collectionsBtn");
      domNftDetailTitle = document.getElementById('nftDetailTitle');
      domNftDetailMintCount = document.getElementById('nftDetailMintCount');
      domNftDetailImg = document.getElementById('nftDetailImg');
      domNftDetailID = document.getElementById('nftDetailID');
      domNftDetailCollection = document.getElementById('nftDetailCollection');
      domNftDetailImageID = document.getElementById('nftDetailImageID');
      domNftDetailOwner = document.getElementById('nftDetailOwner');
      domNftDetailActivity = document.getElementById('nftDetailActivity');
      domNftDetailActions = document.getElementById('nftDetailActions');
      domNftMintSubtitle = document.getElementById('nftMintSubtitle');
      domNftMintOpts = document.getElementById('nftMintOpts');
      domNftMintProgress = document.getElementById('nftMintProgress');
      dom2FAMenu = document.getElementById("2faBtnMenu");
      domStakingTitle = document.getElementById("stakingTitle");
      domStakingSubtitle = document.getElementById("stakingSubtitle");
      domStakingApy = document.getElementById("stakingApy");
      domStakingRoi = document.getElementById("stakingRoi");
      domStakingRewards = document.getElementById("stakingRewards");
      domStakingRedeem = document.getElementById("stakingRedeem");
      // Load settings from disk
      loadSettings();
      // Apply UI settings
      if (!displayDevMenu)
        domCreateTokenBtn.style.display = "none";
      if (!display2FAMenu)
        dom2FAMenu.style.display = "none";
      // Don't need to cache these as it's just one-time use
      if (npmPackage) {
        document.getElementById("version").innerText = "v" + npmPackage.version;
        document.getElementById("versionLogin").innerText = "v" + npmPackage.version;
      } else {
        document.getElementById("version").style.display = "none";
        document.getElementById("versionLogin").style.display = "none";
      }
      switchToLogin();
      init().then(() => {
        // Check for an encrypted wallet, if one exists, pull up the login screen!
        let cWallet = WALLET.getActiveWallet() || new WALLET.Wallet();
        let encwif = false;
        if (cWallet && cWallet.getPrivkeyEnc())
          encwif = cWallet.getPrivkeyEnc();
        else
          localStorage.getItem("encwif");
        if (encwif && encwif.length > 1) {
          console.log("Encrypted key found: " + encwif);
          cWallet.setKeys(null, null, encwif);
          getUnspentTransactions();
        } else {
          // No encrypted wallet available, check for an unencrypted key
          const tmpwifkey = localStorage.getItem("tmpwifkey");
          let tmppass = localStorage.getItem("tmppass");
          if (!tmppass) throw "Unable to find encwif, and no tmppass available, bailing out!";
          console.log("Unable to find encrypted keys, but tmppass is available, checking for imported wifkey...");
          if (tmpwifkey) {
            console.log("Encrypting import key...");
            // Save decrypted copy in memory, immediately erase from disk
            cWallet.setKeys(null, tmpwifkey);
            // This looks strange, but it's happening for pointer-safety reasons, trust me
            cWallet = WALLET.addWallet(cWallet);
            localStorage.removeItem("tmpwifkey");
            // Encrypt wallet and save it to disk
            encryptWallet(tmppass).then(newEncwif => {
              console.log("Encrypted wallet!");
              // Erase the tmppass from disk and memory
              tmppass = null;
              localStorage.removeItem("tmppass");
              // Load the new keys
              const strPubkey = WALLET.sccjs.pubFromPriv(WALLET.getActiveWallet().getPrivkey());
              cWallet.setKeys(strPubkey, null, newEncwif);
              DB.setWallet(WALLET.toDB());
              // Load the Dashboard screen
              switchToDashboard();
              // Give the cache a kick
              setTimeout(() => {
                getBalance(true);
              }, 750);
            });
          } else {
            console.log("Deriving new key...");
            WALLET.createWallet().then(objWallet => {
              // Save decrypted copy in memory
              cWallet.setKeys(objWallet.pubkey, objWallet.privkey);
              // Encrypt wallet and save it to disk
              encryptWallet(tmppass).then(newEncwif => {
                console.log("Encrypted wallet!");
                cWallet.setKeys(null, null, newEncwif);
                DB.setWallet(WALLET.toDB());
                // Erase the tmppass from disk and memory
                tmppass = null;
                localStorage.removeItem("tmppass");
                // Load the Dashboard screen
                switchToDashboard();
              });
            });
          }
        }
      });
    }

    function showTooltip(obj) {
      obj = document.getElementById(obj);
      obj.style.opacity = "1";
      obj.style["z-index"] = "1000";
    }

    function hideTooltip(obj) {
      obj = document.getElementById(obj);
      obj.style.opacity = "0";
      obj.style["z-index"] = "-1000";
    }
  </script>

  <main class="main-body">
    <div class="container marketing pt-navbar" id="dashboardPage">

      <h4 class="mb-5 theme-color-secondary font-weight-bold">Dashboard</h4>

      <div class="row">
        <div class="col-md-7">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Balance<span
                  id="balanceRefresh" onclick="getBlockCount(); getUnspentTransactions();" class="float-end theme-color refresh-button reload hover-darker"><i class="fas fa-redo-alt"></i></span></div>
              <div class="mt-4 theme-color-secondary font-weight-bold">
                <div class="float-end"><span id="guiBalance" class="font-balance">...</span> <span
                    class="font-size-ticker">SCC</span></div><br><br>
                <div class="float-end balance-usd-props"><span
                    id="balanceUSD" class="font-balance-usd font-gray font-weight-normal">...</span> <span
                    class="font-size-ticker-usd font-gray font-weight-normal">USD</span></div>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Activity</div>
              <span id="domActivitySCC" onclick="setActivityView(false);" style="cursor: pointer; opacity: 0.4;" class="badge badge-theme">SCC</span>
              <span id="domActivitySCP" onclick="setActivityView(true);" style="cursor: default;" class="badge badge-theme">SCP</span>
              <div id="activityList" style="overflow-y: auto; max-height: 320px; padding-right: 10px;">
                <center style='margin-top:30px;'><p>You have no activity!</p></center>
              </div>
            </div>
          </div>

        </div>
        <div class="col-md-5">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Overview</div>
              <div class="mt-4 theme-color-secondary font-weight-bold font-size-overview">
                <span class="font-gray">Price:</span>
                <span class="float-end" id="dashboardPrice">Loading...</span><br>
                <span class="font-gray">Marketcap:</span>
                <span class="float-end" id="dashboardMarketcap">Loading...</span><br>
                <span class="font-gray">Current Block:</span>
                <span class="float-end" id="dashboardBlock">Loading...</span>
              </div>
            </div>
          </div>

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" style="margin-bottom:10px;">SCP Tokens</div>
              <span id="domClaimAllBtn" onclick="claimAll();" style="display: none; cursor: pointer;" class="badge badge-theme">Claim All</span>
              <div id="dashboardTokens" style="overflow-y: auto; max-height: 200px; padding-right: 10px; margin-top: 10px;">
                <center><p>Loading SCP</p></center>
              </div>
            </div>
          </div>

        </div>
      </div>


    </div>

    <div class="container marketing pt-navbar" id="sendPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Send</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Transfer coins or tokens</div>

              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> &nbsp;Please make sure to enter the correct address. Transactions cannot be reversed.</div><br>

              <div class="row">
                <div class="col-sm-12">
                  <select id="sendingCoin" class="vodiapicker">
                    <option value="" data-thumbnail="imgs/i.png" disabled selected hidden>-</option>
                    <option value="scc" data-thumbnail="imgs/circular-logo.svg">StakeCubeCoin (SCC)</option>
                  </select>
                  <p>Select Token:</p>
                  <div class="lang-select">
                    <button id="sendingCoinVal" class="btn-select" value="scc"></button>
                    <div class="b" style="z-index:1000;">
                      <ul id="a"></ul>
                    </div>
                  </div>
                </div>
              </div><br>

              <div class="row">
                <div class="col-md-6" style="margin: 20px 0;">
                  <div class="omrs-input-group" style="width:100%; margin-bottom: 0px;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAmount" type="text">
                      <span class="omrs-input-label">Amount</span>
                    </label>
                  </div>
                  <span style="font-size: 13px; top:5px; position: relative;">Available: <span id="sendingCoinBalance" onclick="autofillSendingAmount()" style="cursor: pointer;" class="badge badge-theme" style="margin-bottom:0px">-</label></span>
                </div>

                <div class="col-md-6" style="margin: 20px 0;">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="sendAddress" type="text">
                      <span class="omrs-input-label">Recipient Address</span>
                    </label>
                  </div>
                </div>

                <div class="col text-end"><br>
                  <button class="btn btn-layout btn-theme" id="sendTx" onclick="sendTransactionGUI()">Send Transaction</button><br>
                </div>

                <script>
                  $("#sendTx").on("keydown", function(e){
                    if(e.keyCode === 13){
                      if (!allowEnterKey) e.preventDefault();
                    }
                  });
                </script>
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="receivePage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Receive</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Receive address</div>
              <div class="alert alert-danger-custom" style="font-size:13px;"><i class="fas fa-exclamation-triangle"></i> Please make sure to only send SCC or SCP tokens to this address. Other coins will be lost and cannot be reversed.</div><br>
              
              <center>
                <div onclick="copyToClipboard(WALLET.getActiveWallet().getPubkey(), 'Address')" class="refresh-button hover-darker">
                  <span id="receiveAddress" class="font-weight-bold"></span>
                  <span style="padding-left:6px;">
                    <i class="far fa-copy"></i>
                  </span>
                </div>
              </center>
              <br>
              <center><img id="receiveQR" style="width: 25%;height:auto;image-rendering:pixelated;"></center>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="authPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">StakeCube 2FA</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div id="authTitle" class="card-title font-gray font-weight-bold">Setup your 2FA</div>
                <div class="alert alert-danger-custom" style="font-size:13px;">
                  <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i>Do <b>not</b> share these codes with <b>anyone!</b>
                </div>
                <div class="alert alert-warning-custom" style="font-size:13px;">
                  <i class="fas fa-info-circle" style="margin-right: 6px;"></i> The 2FA screen can be used as an in-wallet 2FA app for your StakeCube.net account, if you haven't already setup 2FA on your StakeCube.net account, use this and secure your account with your wallet!<br><br>
                  To find your 2FA settings, login to StakeCube.net, visit your settings, and copy your 2FA "Secret", below the QR code, into the "Secret Code" section of this 2FA screen, then you're secured!
                </div><br>
                <div id="authImport">
                  <div class="omrs-input-group" style="width:100%;">
                    <label class="omrs-input-underlined">
                      <input required id="authSecretImport" type="text" autofocus>
                      <span class="omrs-input-label">2FA</span>
                    </label>
                  </div>
                  
                  <center><button onclick="import2FA()" style="margin-top: 10px;" class="btn btn-theme btn-layout">Import</button></center>
                  <br>
                </div>
                <center id="authDisplay">
                  <div onclick="copyToClipboard(document.getElementById('authCode').innerText, '2FA code')" class="refresh-button hover-darker">
                    <span id="authCode" style="font-size: x-large;" class="font-weight-bold"></span>
                    <i  style="padding-left:6px;" class="far fa-copy refresh-button"></i>
                  </div>
                  <p id="authTime" style="opacity: 0.8;">10 seconds left til next code</p>
                  <br>
                </center>
              <center id="authReset"><button onclick="remove2FA()" style="margin-top: 10px;" class="btn btn-danger btn-layout">Remove 2FA</button></center>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="container marketing pt-navbar" id="stakingPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">SCP-2 Staking</h4>

      <center>
        <h3>Est. APR of <b id="stakingApy">---</b></h3>
      </center>
      <br>
      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold" id="stakingTitle">Loading...</div>
              <br>
              <center>
                <p id="stakingSubtitle">Loading...</p>
                <h2 id="stakingRewards">...</h2>
                <p id="stakingRoi" style="opacity:0.5;"></p>
                <br>
                <button id="stakingRedeem" class="btn btn-layout btn-theme disabled" onclick="redeemTokens()">Claim Rewards</button>
              </center><br><br>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container marketing pt-navbar" id="settingsPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Settings</h4>


      <div class="card card-prop mb-4">
        <div class="card-body">

          <div class="accordion" id="accordionExample">
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingOne">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                  <span class="darkText">Personalization</span>
                </button>
              </h2>
              <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                  
                  <div class="row" style="display: none;">
                    <div class="col-9">
                      <span style="font-size:14px;">How many taco's do you want for dinner?</span><br>
                      <span style="font-size:11px; color:#97a1b1;">Basicly a description of the taco here</span>
                    </div>
                    <div class="col-3">
                      <select class="form-select form-select-sm" aria-label=".form-select-sm example">
                        <option selected>Open this select menu</option>
                        <option value="1">One</option>
                        <option value="2">Two</option>
                        <option value="3">Three</option>
                      </select>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2; display: none;">

                  <div class="row">
                    <div class="col-9">
                      <span>Allow 'Enter' key to continue actions</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will mean hitting 'Enter' will not perform or continue any actions or dialogs.<br>This setting is ignored on all Password fields.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="allowEnterKeySetting" checked="true" setting="allowEnterKey" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Display the 2FA menu</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will hide the 2FA button from the header menu.<br>This will not remove or lose any 2FA codes, only hide them visually.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="display2FAMenuSetting" checked="true" setting="display2FAMenu" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Limit Activity to 200 TXs</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will let the Activity display unlimited TXs, however this may cause performance issues on large wallets.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="limitActivitySetting" checked="true" setting="limitActivity" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <hr style="color: #bcc4d2;">

                  <div class="row">
                    <div class="col-9">
                      <span>Hide Empty Wallets</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Disabling this will display empty (0-balance) wallets in their respective area.</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="hideZeroBalanceSetting" checked="true" setting="hideZeroBalance" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <hr style="color: #bcc4d2;">
                  
                  <div class="row">
                    <div class="col-9">
                      <span>Display the SCP Developer menu</span><br>
                      <span style="font-size:12px; color:#97a1b1;">Enabling this will display the SCP Developer Toolkit menu.<br>This page can be used for creating, deploying and interacting with custom DApps!</span>
                    </div>
                    <div class="col-3">
                      <div class="container">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <div class="form-check form-switch">
                              <input class="form-check-input darkBorder" type="checkbox" value="" id="displayDevMenuSetting" checked="false" setting="displayDevMenu" onclick="toggleSetting(this)">
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="accordion-item">
              <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">
                  <span class="darkText">Wallet</span>
                </button>
              </h2>
              <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                  <div class="row">
                    <div class="col-sm-9">
                      <span>Export Wallet</span><br>
                      <span style="font-size:12px; color:#97a1b1;">This will highlight your private wallet file in your file explorer. You can use this file to move your wallet to another device, or as an encrypted backup method. (Contains: Encrypted Privkey, Pubkey & 2FA secret)</span>
                    </div>
                    <div class="col-sm-3">
                      <div class="container" style="padding: 10px 0;">
                        <div class="row align-items-center justify-content-center" style="height: 100%;">
                          <div class="col-md-6">
                            <button class="btn btn-primary" onclick="showFileInExplorer(DB.appdata.getAppDataPath('SCPWallet\\wallet.json'))" style="width: 100%; min-width: 80px;">Export</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <div class="container marketing pt-navbar" id="createTokenPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Create Token</h4>

      <div class="row">
        <div class="col-lg-8 offset-lg-2">

          <div class="card card-prop mb-4">
            <div class="card-body">
              <div class="card-title font-gray font-weight-bold">Token information</div>

              <script>
                let nDeploymentVer = 0;
                function changeTokenType(obj) {
                  domScpTokenDeployArea.style.display = 'block';
                  document.getElementById('scpTokenSettings').style.display = '';
                  const strDesc = document.getElementById('scpTokenDescription');
                  nDeploymentVer = Number(obj.options[obj.selectedIndex].value);
                  if (obj.options[obj.selectedIndex].value == '1') {
                    document.getElementById('scp2TokenSettings').style.display = 'none';
                    document.getElementById('scp2TokenSettings2').style.display = 'none';
                    document.getElementById('scp4TokenSettings').style.display = 'none';
                    strDesc.innerText = 'SCP-1 is a minimalistic issuer-minted token, featuring on-demand issuer minting, burns from anyone, and a max supply cap for barebones security.';
                  } else if (obj.options[obj.selectedIndex].value == '2') {
                    strDesc.innerText = 'SCP-2 is an advanced SCP-1 variant, with trustworthy issuance based on fair and fractional PoS, incentivising users to hold for long periods.';
                    document.getElementById('scp2TokenSettings').style.display = 'flex';
                    document.getElementById('scp2TokenSettings2').style.display = 'flex';
                    document.getElementById('scp4TokenSettings').style.display = 'none';
                  } else if (obj.options[obj.selectedIndex].value == '4') {
                    strDesc.innerText = 'SCP-4 is an NFT Standard which allows deploying "Collections" with NFT max-mints, burn protection and IPFS image enforcement.';
                    document.getElementById('scpTokenSettings').style.display = 'none';
                    document.getElementById('scp2TokenSettings').style.display = 'none';
                    document.getElementById('scp2TokenSettings2').style.display = 'none';
                    document.getElementById('scp4TokenSettings').style.display = 'flex';
                  }

                  // Force a re-check of the params
                  checkDeployerInput();
                }

                // Write an 'oninput' function that checks all inputs, logs errors in the below warning div, and disables button until good
                function checkDeployerInput() {
                    // Reset the warning error
                    domScpTokenErrors.innerHTML = "";
                    let isComplete = true;

                    // SCP-1 CHECKS
                    if (nDeploymentVer === 1 || nDeploymentVer === 2) {
                      // Name
                      if (domScpTokenName.value.length) {
                          // Swap spaces for artificial whitespace unicodes
                          domScpTokenName.value = domScpTokenName.value.replace(/ /g, ' ');
                          // Limit to 25 characters
                          if (domScpTokenName.value.length > 25) domScpTokenName.value = domScpTokenName.value.substr(0, 25);
                      } else {
                          isComplete = false;
                      }

                      // Ticker
                      if (domScpTokenTicker.value.length) {
                          // Remove all whitespace
                          domScpTokenTicker.value = domScpTokenTicker.value.replace(/ /g, '').trim();
                          // Limit to 6 characters
                          if (domScpTokenTicker.value.length > 6) domScpTokenTicker.value = domScpTokenTicker.value.substr(0, 6);
                      } else {
                          isComplete = false;
                      }

                      // Supply
                      if (domScpTokenSupply.value.length) {
                          // Remove all whitespace
                          domScpTokenSupply.value = domScpTokenSupply.value.replace(/ /g, '').trim();
                          const nSupply = Number(domScpTokenSupply.value * COIN);
                          // Supply must be 1 coin minimum
                          if (nSupply < COIN) {
                              domScpTokenErrors.innerHTML += 'Supply: Minimum is 1!<br>';
                              isComplete = false;
                          }
                          // Do not allow supplies larger than the safe integer
                          if (!Number.isSafeInteger(nSupply)) {
                              domScpTokenErrors.innerHTML += 'Supply: Max supply is ' + (Math.floor((Number.MAX_SAFE_INTEGER / COIN) / 1000000)).toLocaleString('en-GB', { maximumFractionDigits: 0 }) + 'm!<br>';
                              isComplete = false;
                          }
                      } else {
                          isComplete = false;
                      }
                    }
                    
                    // SCP-2 CHECKS
                    if (nDeploymentVer === 2) {
                        // Block Reward
                        if (domScpTokenPoSReward.value.length) {
                            // Remove all whitespace
                            domScpTokenPoSReward.value = domScpTokenPoSReward.value.replace(/ /g, '').trim();
                            const nReward = Number(domScpTokenPoSReward.value * COIN);
                            // Reward must be a number
                            if (!Number.isFinite(nReward)) {
                                domScpTokenErrors.innerHTML += 'Rewards: Must be a number!<br>';
                                isComplete = false;
                            }
                            // Reward cannot be smaller than 0.0001 coins
                            if (nReward < (0.001 * COIN)) {
                                domScpTokenErrors.innerHTML += 'Rewards: Cannot be smaller than 0.0001!<br>';
                                isComplete = false;
                            }
                            const nSupply = Number(domScpTokenSupply.value * COIN);
                            // Reward cannot be equal to the max supply
                            if (nReward === nSupply) {
                                domScpTokenErrors.innerHTML += 'Rewards: Cannot be equal to the max supply!<br>';
                                isComplete = false;
                            }
                            // Reward cannot be larger than to the max supply
                            if (nReward > nSupply) {
                                domScpTokenErrors.innerHTML += 'Rewards: Cannot be larger than the max supply!<br>';
                                isComplete = false;
                            }
                        } else {
                            isComplete = false;
                        }

                        // Min Stake Age
                        if (domScpTokenMinAge.value.length) {
                            // Remove all whitespace
                            domScpTokenMinAge.value = domScpTokenMinAge.value.replace(/ /g, '').trim();
                            const nMinAge = Number(domScpTokenMinAge.value);
                            // Min Age must be an integer
                            if (!Number.isInteger(nMinAge)) {
                                domScpTokenErrors.innerHTML += 'Min Age: Must be an integer!<br>';
                                isComplete = false;
                            }
                            // Min Age must be atleast 1 block
                            if (nMinAge < 1) {
                                domScpTokenErrors.innerHTML += 'Min Age: Must be atleast 1 block!<br>';
                                isComplete = false;
                            }
                            // Min Age must be a safe integer
                            if (Number.isInteger(nMinAge) && !Number.isSafeInteger(nMinAge)) {
                                domScpTokenErrors.innerHTML += 'Min Age: Too large to be safe!<br>';
                                isComplete = false;
                            }
                        } else {
                            isComplete = false;
                        }
                    }

                    // SCP-4 CHECKS
                    if (nDeploymentVer === 4) {
                        // Name
                        if (domScpCollectionName.value.length) {
                            // Swap spaces for artificial whitespace unicodes
                            domScpCollectionName.value = domScpCollectionName.value.replace(/ /g, ' ');
                            // Limit to 40 characters
                            if (domScpCollectionName.value.length > 40) domScpCollectionName.value = domScpCollectionName.value.substr(0, 40);
                        } else {
                            isComplete = false;
                        }

                        // Max Mints
                        if (domScpCollectionMaxMints.value.length) {
                            // Remove all whitespace
                            domScpCollectionMaxMints.value = domScpCollectionMaxMints.value.replace(/ /g, '').trim();
                            const nMaxMints = Number(domScpCollectionMaxMints.value);
                            // Max Mints must be an integer
                            if (!Number.isInteger(nMaxMints)) {
                                domScpTokenErrors.innerHTML += 'Max Mints: Must be an integer!<br>';
                                isComplete = false;
                            }
                            // Max Mints must be larger than 0, or -1 for unlimited
                            if (nMaxMints < 1 && nMaxMints !== -1) {
                                domScpTokenErrors.innerHTML += 'Max Mints: Must be atleast 1 mint! (Or -1 for unlimited)<br>';
                                isComplete = false;
                            }
                            // Max Mints must be a safe integer
                            if (Number.isInteger(nMaxMints) && !Number.isSafeInteger(nMaxMints)) {
                                domScpTokenErrors.innerHTML += 'Max Mints: Too large to be safe!<br>';
                                isComplete = false;
                            }
                        } else {
                            isComplete = false;
                        }
                    }

                    // Apply any error messages, if they exist
                    if (domScpTokenErrors.innerHTML.length) {
                        document.getElementById('scpTokenErrorsWidget').style.display = '';
                        domScpTokenDeployBtn.setAttribute('disabled', '');
                    } else {
                        document.getElementById('scpTokenErrorsWidget').style.display = 'none';
                        if (isComplete)
                          domScpTokenDeployBtn.removeAttribute('disabled');
                    }

                    // Disable the button if the form isn't complete
                    if (!isComplete) {
                        domScpTokenDeployBtn.setAttribute('disabled', '');
                    }
                }

                function guiDeploySCP() {
                    // Cannot deploy if the button is disabled (due to unsatisfied inputs)
                    if (domScpTokenDeployBtn.hasAttribute('disabled')) return;
                    // Convert the input into SCP params
                    const arrParams = [];

                    // SCP-1 Spec
                    if (nDeploymentVer === 1) {
                        // Name
                        arrParams.push(domScpTokenName.value);
                        // Ticker
                        arrParams.push(domScpTokenTicker.value);
                        // Supply
                        arrParams.push((Number(domScpTokenSupply.value) * COIN).toString());
                    }

                    // SCP-2 Spec
                    if (nDeploymentVer === 2) {
                        // Name
                        arrParams.push(domScpTokenName.value);
                        // Ticker
                        arrParams.push(domScpTokenTicker.value);
                        // Supply
                        arrParams.push((Number(domScpTokenSupply.value) * COIN).toString());
                        // PoS Reward
                        arrParams.push((Number(domScpTokenPoSReward.value) * COIN).toString());
                        // Min Stake Age
                        arrParams.push(domScpTokenMinAge.value);
                    }

                    // SCP-4 Spec
                    if (nDeploymentVer === 4) {
                        // Collection Name
                        arrParams.push(domScpCollectionName.value);
                        // Max Mints
                        arrParams.push(domScpCollectionMaxMints.value);
                        // Protected
                        arrParams.push(domScpCollectionProtected.checked ? '1' : '0');
                    }

                    if (arrParams.length > 1)
                        deploySCP(nDeploymentVer, arrParams);
                }
              </script>

              <div class="alert alert-danger-custom" style="font-size:13px; display: none;" id="scpTokenErrorsWidget">
                <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i><b id="scpTokenErrors"></b>
              </div>

              <select id="scpDeploySelector" class="form-select" oninput="changeTokenType(this)" style="margin-bottom: 20px;">
                <option selected disabled>Token type</option>
                <option value="1">SCP-1</option>
                <option value="2">SCP-2</option>
                <option value="4">SCP-4</option>
              </select>

              <div class="col-md-12">
                <div style="width:100%;">
                    <p id='scpTokenDescription' style="text-align: center;">
                      Select a token standard to get started!
                    </p>
                </div>
              </div>
              
              <hr style="color: #bcc4d2;">

              <div id="scpTokenSettings" style="display: none;">
                <div class="row">
                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenName" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Token Name</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('tokenNameTip')"
                        onmouseout="hideTooltip('tokenNameTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="tokenNameTip" style="z-index: -1000;">The public name of your token, displayed on SCP Wallet, Explorers, etc.</span>
                      </label>
                    </div>
                  </div>

                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenTicker" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Token Ticker</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('tokenTickerTip')"
                        onmouseout="hideTooltip('tokenTickerTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="tokenTickerTip" style="z-index: -1000;">The public ticker of your token, displayed on SCP Wallet, Explorers, etc.</span>
                      </label>
                    </div>
                  </div>
                </div>

                <div class="row">
                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenSupply" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Max Supply</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('maxSupplyTip')"
                        onmouseout="hideTooltip('maxSupplyTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="maxSupplyTip" style="z-index: -1000;">The maximum amount of tokens that can exist at once.</span>
                      </label>
                    </div>
                  </div>

                  <div class="col-md-6">
                    <div id="scp2TokenSettings" style="display:none;">
                      <div class="omrs-input-group" style="width:100%;">
                        <label class="omrs-input-underlined">
                          <input id="scpTokenPoSReward" oninput="checkDeployerInput()" required type="text">
                          <span class="omrs-input-label">Block Reward</span>
                          <span class="omrs-input-hover" onmouseover="showTooltip('blockRewardTip')"
                          onmouseout="hideTooltip('blockRewardTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                        <span class="omrs-input-message" id="blockRewardTip" style="z-index: -1000;">The reward per-block in tokens, distributed in proportional fractions to stakeholders.</span>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="row" style="display:none;" id="scp2TokenSettings2">
                  <div class="col-md-6">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpTokenMinAge" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Minimum Staking Age</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('stakingAgeTip')"
                          onmouseout="hideTooltip('stakingAgeTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                        <span class="omrs-input-message" id="stakingAgeTip" style="z-index: -1000;">The minimum time, in blocks, that tokens must stay untouched before earning staking rewards.</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>

              <div id="scp4TokenSettings" style="display: none;">
                <div class="row">
                  <div class="col-md-8">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpCollectionName" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Collection Name</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('collectionNameTip')"
                        onmouseout="hideTooltip('collectionNameTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="collectionNameTip" style="z-index: -1000;">The public name of your NFT Collection, displayed on SCP Wallet, SC Marketplace, Explorers, etc.</span>
                      </label>
                    </div>
                  </div>

                  <div class="col-md">
                    <div class="omrs-input-group" style="width:100%;">
                      <label class="omrs-input-underlined">
                        <input id="scpCollectionMaxMints" oninput="checkDeployerInput()" required type="text">
                        <span class="omrs-input-label">Max Mints</span>
                        <span class="omrs-input-hover" onmouseover="showTooltip('collectionMaxMintsTip')"
                        onmouseout="hideTooltip('collectionMaxMintsTip')"><i class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="collectionMaxMintsTip" style="z-index: -1000;">Maximum NFT mints allowed.<br><br>Use -1 for unlimited minting.</span>
                      </label>
                    </div>
                  </div>

                  <div class="row" style="margin-bottom: 1em;">
                    <div class="col" style="text-align: center;padding-right: 0px;">
                      <span>Protected</span>
                      <div class="form-check form-switch" style="width: 100%;display: flex;padding-left: 4px;margin-top: 5px;">
                        <input class="form-check-input darkBorder" type="checkbox" value="" id="scpCollectionProtected" checked="true" style="margin-left: auto;margin-right: auto;">
                      </div>
                      <span style="font-size:12px;color:#97a1b1;">Disabling this will allow NFTs in this Collection to be burned by its holders.</span>
                    </div>
                  </div>
                  <hr style="color: #bcc4d2;">
                </div>
              </div>

              <center id="scpTokenDeployArea" style="display: none;">
                <button id="scpTokenDeployBtn" onclick="guiDeploySCP()" disabled style="margin-top: 10px;" class="btn btn-theme btn-layout">Create token</button>
                <p style="margin-top: 20px;opacity: 0.35;">Deploying an SCP Token requires a fixed deployment fee of 10 SCC!</p>
              </center>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-fluid marketing pt-navbar" id="viewCollection">
      <div class="container-fluid" style="margin-top: 10px;">

        <h4 class="mb-5 theme-color-secondary font-weight-bold" id="collectionName">My NFTs</h4>

        <div class="float-end" style="margin-top:-50px;">
          <button type="button" id="scpNftMintBtn" class="btn btn-theme btn-sm" style="margin-right:0.5em;" onclick="switchToNftCreator()">Mint NFT</button>
          <button type="button" class="btn btn-theme btn-sm" onclick="switchToCollections()">Explore All Collections</button>
        </div>

        <div id="nftSearch" class="omrs-input-group" style="min-width: 50%;margin-left: auto;margin-right: auto;max-width: 100%;">
          <label class="omrs-input-underlined">
            <input class="darkerInput" oninput="renderNFTs(nSelectedCollection, this.value.replace(/ /g, ' ').toLowerCase())" required="" type="text">
            <span class="omrs-input-label">Search (name, contract or creator)</span>
            <span class="omrs-input-hover"><i class="fas fa-search tooltip-questionmark"></i></span>
          </label>
        </div>

        <div class="row d-flex justify-content-center" id="nftList"></div>
      </div>
    </div>



    <div class="container-fluid marketing pt-navbar" id="NFTCollections">
      <div class="container">
        <h4 class="mb-5 theme-color-secondary font-weight-bold">NFT Collections</h4>

        <div class="float-end" style="margin-top:-50px;">
          <button type="button" class="btn btn-theme btn-sm" style="margin-right:0.5em;" onclick="switchToCreateToken('4')">Create Collection</button>
          <button type="button" class="btn btn-theme btn-sm" onclick="switchToViewCollection();renderNFTs(-1);">My NFTs</button>
        </div>

        <div class="omrs-input-group" style="min-width: 50%;margin-left: auto;margin-right: auto;max-width: 100%;">
          <label class="omrs-input-underlined">
            <input class="darkerInput" id="collectionSearch" oninput="renderCollections(this.value.replace(/ /g, ' ').toLowerCase())" required="" type="text">
            <span class="omrs-input-label">Search (name, contract or creator)</span>
            <span class="omrs-input-hover"><i class="fas fa-search tooltip-questionmark"></i></span>
          </label>
        </div>

        <div class="card card-prop mb-4">
          <div class="card-body">
            <div class="card-title font-gray font-weight-bold">Collections</div>
            <table class="table table-hover">
              <thead>
                <tr>
                  <th scope="col">Name</th>
                  <th scope="col">Supply</th>
                  <th scope="col">Max Mints</th>
                  <th scope="col">Protected</th>
                  <th scope="col">Actions</th>
                </tr>
              </thead>

              <tbody id="collectionsList">
                <tr>
                  <td>Loading...</td>
                  <td>...</td>
                  <td>...</td>
                  <td><span class="subtext">...</span></td>
                  <td style="padding-top: 11px;">...</td>
                </tr>
              </tbody>
            </table>

          </div>    
        </div>


      </div>
    </div>



    <div class="container-fluid marketing pt-navbar" id="viewNFT">
      <div class="container">
        <div class="d-inline-flex flex-column lh-sm" style="position: relative; top: -7px">
          <span id="nftDetailTitle" class="hover-darker" onclick="copyToClipboard(this.innerText, 'Name')" style="font-size:x-large;cursor:pointer;"></span>
          <span id="nftDetailMintCount" style="font-size:0.75em;background-color: transparent;" class="kbd">
            <b></b><b style="opacity: 0.75"></b>
          </span>
        </div>
        <div class="float-end">
          <button type="button" id="nftDetailCollection" class="btn btn-theme btn-sm" onclick="switchToViewCollection();renderNFTs();" style="margin-right:1em;">Visit Collection</button>
          <button type="button" class="btn btn-theme btn-sm" onclick="switchToViewCollection();renderNFTs();">Back</button>
        </div>

        <div class="row">
          <div class="col-4">
            <img id="nftDetailImg" class="hover-darker" onclick="copyToClipboard(this.src, 'Image URL')" style="width:100%;border-radius: 10px;cursor:pointer;">
            <div id="nftDetailActions" class="card card-prop mt-4">
              <div class="card-body" style="padding-top: 9px;">
                <div class="card-title font-gray font-weight-bold">Actions</div>
                <div class="row">
                  <div class="col-6" style="padding-right: 3px;">
                    <button type="button" id="nftTransferBtn" class="btn btn-theme btn-sm w-100" data-bs-toggle="modal" data-bs-target="#sendNftModal">Transfer</button>
                  </div>
                  <div class="col-6" style="padding-left: 3px;">
                    <button type="button" id="nftBurnBtn" class="btn btn-theme btn-sm w-100" style="background-color:#e08080;" data-bs-toggle="modal" data-bs-target="#burnNftModal">Burn</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-8">
            <div class="card card-prop mb-4">
              <div class="card-body">
                <div class="card-title font-gray font-weight-bold">Details</div>

                <div style="font-size:12px;">
                  <div class="row">
                    <div class="col">
                      <span class="ls-1">ID</span>
                      <br>
                      <code id="nftDetailID" onclick="copyToClipboard(this.innerText, 'NFT ID')" style="cursor:pointer" class="kbd hover-darker"></code>
                    </div>
                  </div><br>

                  <span class="ls-1">IPFS CID</span><br>
                  <span id="nftDetailImageID" onclick="copyToClipboard(this.innerText, 'IPFS CID')" style="cursor:pointer" class="kbd hover-darker"></span><br><br>

                  <span class="ls-1">OWNER ADDRESS</span><br>
                  <code id="nftDetailOwner" onclick="copyToClipboard(this.innerText, 'Address')" style="cursor:pointer" class="kbd hover-darker"></code>
                </div>
              </div>
            </div>

            <div class="card card-prop mb-4">
              <div class="card-body">
                <div class="card-title font-gray font-weight-bold">Activity</div>

                <table class="table table-hover" style="font-size:13px;">
                  <thead>
                    <tr>
                      <th scope="col">TX</th>
                      <th scope="col">Type</th>
                      <th scope="col">From</th>
                      <th scope="col">To</th>
                      <th scope="col">Block</th>
                    </tr>
                  </thead>
                  <tbody id="nftDetailActivity"></tbody>
                </table>

              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
    <script>
      function switchToNftCreator() {
        const cColl = isFullnode ? NFT.getCollection(nSelectedCollection) : getCachedCollection(nSelectedCollection);
        closeAllTabs();
        domCreateNftPage.style.display = 'block';
        domNftMintSubtitle.innerText = cColl.collectionName + ': Mint an NFT';
      }

      let bRawImageBuf;
      async function uploadImageDialog() {
        const ret = await dialog.showOpenDialog({
          'title': 'Select an Image for your NFT',
          'filters': [
            { name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif'] }
          ],
          'properties': [
            'openFile',
            'treatPackageAsDirectory'
          ]
        });
 
        if (ret === undefined || ret.canceled || !ret.filePaths.length) return false;
        // Load file into buffer
        bRawImageBuf = DB.fs.readFileSync(ret.filePaths[0]);
        // Update UI
        const domPreview = document.getElementById('nftPreviewImg');
        // Figure out what filetype we're working with, for rendering purposes
        const dotSplit = ret.filePaths[0].split('.');
        const fileType = dotSplit[dotSplit.length - 1].toLowerCase();
        // Encode buffer as native base64, remove any formatting lines, inject into renderer
        domPreview.style['background-image'] = 'url(data:image/' + fileType + ';base64,' + bRawImageBuf.toString('base64').replace(/(\r\n|\n|\r)/gm, '') + ')';
        domPreview.style['background-repeat'] = 'no-repeat';
        domPreview.style['background-position'] = 'center';
        checkNftInput();
        return await bRawImageBuf;
      }

      let nLastImageLen = 0;
      let strLastImageCID = '';
      async function nftUpload() {
        // Cannot deploy if the button is disabled (due to unsatisfied inputs)
        if (document.getElementById('scpNftDeployBtn').hasAttribute('disabled')) return;
        const intervals = Number(document.getElementById('scpNftDeployQty').value);
        domNftMintOpts.style.display = 'none';
        domNftMintProgress.style.display = 'block';
        const cText = document.getElementById('mintText');
        cText.innerText = 'Warming Up';
        await sleep(500);
        const cProgress = document.getElementById('mintProgress');
        cProgress.style.width = '10%';
        await sleep(1000);
        try {
          const fAlreadyUploaded = bRawImageBuf.length === nLastImageLen;
          cProgress.style.width = (fAlreadyUploaded ? '50' : '20') + '%';
          cText.innerText = fAlreadyUploaded ? 'Fetching cached IPFS CID' : 'Uploading image to IPFS';
          const cRetIPFS = !fAlreadyUploaded ? JSON.parse(await NET.uploadToIPFS(bRawImageBuf)) : undefined;
          try {
            for (let i = 0; i<intervals; i++) {
              const fLastMint = i === intervals - 1;
              if ((fAlreadyUploaded && strLastImageCID) || (cRetIPFS && cRetIPFS.ok && cRetIPFS.value.cid.length)) {
                // Prepare the progress text
                const strInterval = !fLastMint ? ' (' + (i+1) + '/' + intervals + ')' : '';
                // Fetch the latest UTXOs
                cProgress.style.width = '70%';
                cText.innerText = 'Preparing UTXOs' + strInterval;
                const strAddr = WALLET.getActiveWallet().getPubkey();
                await WALLET.refreshUTXOs(strAddr);
                // Construct mint transaction
                const strName = document.getElementById('scpNftName').value;
                cProgress.style.width = '80%';
                cText.innerText = 'Minting "' + formatName(strName, 24) + '"' + strInterval;
                console.log('NFT Uploader: ' + (fAlreadyUploaded ?
                                              'Using cached CID' :
                                              'Uploaded new image (' + bRawImageBuf.length + 'b) to IPFS'));
                // Save the image byte length (this will be used to prevent re-uploads of the same image)
                nLastImageLen = bRawImageBuf.length;
                // Grab the IPFS CID
                const strCID = fAlreadyUploaded ? strLastImageCID : cRetIPFS.value.cid;
                strLastImageCID = strCID;
                // Prepare wallet
                const cCollection = isFullnode ? NFT.getCollection(nSelectedCollection) : getCachedCollection(nSelectedCollection);
                console.log("Constructing SCP-" + cCollection.version + " NFT mint TX!");
                // Contruct SCP transaction
                const cTx = WALLET.sccjs.tx.transaction();
                // Add input
                const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
                if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
                cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
                // SCP output
                cTx.addoutputburn(0.00000001, cCollection.contract + ' mint ' + strName + ' ' + strCID);
                // Fee & Change output
                const nFee = WALLET.getFee(cTx.serialize().length);
                const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
                cTx.addoutput(strAddr, nChange);
                // Sign
                cText.innerText = 'Signing TX' + strInterval;
                const strSignedTx = await cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1);
                cProgress.style.width = '90%';
                // Broadcast
                cText.innerText = 'Broadcasting TX' + strInterval;
                const strTXID = await WALLET.broadcastTx(strSignedTx);
                cUTXO.spent = true;
                if (fLastMint) {
                  strLastNftID = strTXID;
                  M.toast({html: 'Minting! Please wait for block confirmations!', displayLength: 5000});
                  cProgress.style.width = '100%';
                  cText.innerText = 'Done!';
                  if (isFullnodePtr()) {
                    getMempoolActivity(strAddr).then(arrRes => cachedActivityIS = arrRes);
                  } else {
                    NET.getMempoolActivityLight(strAddr).then(strRes => {
                      cachedActivityIS = JSON.parse(strRes);
                    });
                    getUnspentTransactions();
                    // Updates NFTs and other contracts
                    getMempoolActivity(strAddr);
                  }
                  setTimeout(() => {
                    cProgress.style.width = '0%';
                    domNftMintOpts.style.display = 'block';
                    domNftMintProgress.style.display = 'none';
                  }, 2500);
                }
              } else {
                cProgress.style.width = '0%';
                domNftMintOpts.style.display = 'block';
                domNftMintProgress.style.display = 'none';
                return M.toast({html: 'IPFS Upload failed, retry later!', displayLength: 3000});
              }
            }
          } catch (e) {
            console.error('NFT Broadcast error: Likely a wallet or UTXO set issue, please wait for one block before re-attempting!');
            console.error(e);
            M.toast({html: 'Mint error! Please re-try in one block, wallet may be exhausted.', displayLength: 5000});
            cProgress.style.width = '100%';
            cText.innerText = 'Broadcast Failure!';
            setTimeout(() => {
              cProgress.style.width = '0%';
              domNftMintOpts.style.display = 'block';
              domNftMintProgress.style.display = 'none';
            }, 2500);
          }
        } catch (e) {
          console.log(e);
          cProgress.style.width = '0%';
          domNftMintOpts.style.display = 'block';
          domNftMintProgress.style.display = 'none';
          return M.toast({html: 'Failed to reach IPFS Node, retry later!', displayLength: 3000});
        }
      }

      function checkNftInput() {
        let isComplete = true;

        // Name
        const nftName = document.getElementById('scpNftName');
        if (nftName.value) {
          // Swap spaces for artificial whitespace unicodes
          nftName.value = nftName.value.replace(/ /g, ' ');
          // Limit to 25 characters
          if (nftName.value.length > 25) nftName.value = nftName.value.substr(0, 25);
          // Set the display name
          document.getElementById('nftCreatorName').innerText = nftName.value;
        } else {
          isComplete = false;
        }

        // Image
        if (!bRawImageBuf || !bRawImageBuf.length) {
          isComplete = false;
        }

        if (isComplete) {
          document.getElementById('scpNftDeployBtn').removeAttribute('disabled');
        } else {
          document.getElementById('scpNftDeployBtn').setAttribute('disabled', '');
        }
      }
    </script>

    <div class="container marketing pt-navbar" id="createNftPage">
      <h4 class="mb-5 theme-color-secondary font-weight-bold">Mint NFT</h4>
      
      <div class="float-end" style="margin-top:-50px;">
        <button type="button" class="btn btn-theme btn-sm" onclick="switchToViewCollection()">Visit Collection</button>
      </div>
    
      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <div class="card card-prop mb-4">
            <div class="card-body">
              <div id="nftMintSubtitle" class="card-title font-gray font-weight-bold">NFT information</div>

              <div class="alert alert-danger-custom" style="font-size:13px; display: none;" id="scpTokenErrorsWidget">
                <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i><b id="scpTokenErrors"></b>
              </div>

              <hr style="color: #bcc4d2;">

              <div class="row">
                <div class="col-md">
                  <div class="omrs-input-group" style="width: 50%;margin-left: auto;margin-right: auto;min-width: 250px;">
                    <label class="omrs-input-underlined">
                      <input id="scpNftName" oninput="checkNftInput()" required type="text">
                      <span class="omrs-input-label">Name</span>
                      <span class="omrs-input-hover" onmouseover="showTooltip('nftNameTip')"
                        onmouseout="hideTooltip('nftNameTip')"><i
                          class="fas fa-question-circle tooltip-questionmark"></i></span>
                      <span class="omrs-input-message" id="nftNameTip" style="z-index: -1000;">The public name of your
                        NFT, displayed on SCP Wallet, Explorers, etc.</span>
                    </label>
                  </div>
                </div>
              </div>
              <div class="row">
                <div class="col-md">
                  <div class="col-3" style="width: 100%;">
                    <div class="card card-prop nftCard" id="nftPreviewImg" onclick="uploadImageDialog()" style="background-color: #08429838 !important;height: 250px;margin-left: auto;margin-right: auto;width: 175px;">
                      <div class="card-body refresh-button">
                        <span id="nftCreatorName" class="badge nftname">Click to edit image</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <center id="nftMintOpts">
                <br>
                <h5>
                  Quantity of NFT Mints
                  <input id="scpNftDeployQty" type="range" class="form-range" value="1" min="1" max="20" id="nftQuantity">
                </h5>
                <p style="opacity:0.3;font-size:0.7em;margin-top:1rem;margin-bottom: 0;">Minting NFTs is FREE! There are no additional costs for minting, minus blockchain fees.</p>
                <button id="scpNftDeployBtn" onclick="nftUpload()" disabled="" style="margin-top: 10px;" class="btn btn-theme btn-layout">Start Minting</button>
              </center>
              <center id="nftMintProgress" style="display: none;">
                <h5 id="mintText" style="margin-bottom: 0.5em; margin-top: 0.5em;">Initializing Minter</h5>
                <div class="progress" style="border-color:#0d6efd;border-style:solid;border-width:1px;">
                  <div id="mintProgress" class="progress-bar" role="progressbar" style="width: 0%;background: linear-gradient(90deg, rgba(3, 23, 52, 0.97), #0a58ca 100%);" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
              </center>
              </div>
            </div>
          </div>
        </div>
      </div>
    

    <script>
      let cSelectedNFT;
      function sendNftGUI() {
        const strTo = document.getElementById('sendAddressNft').value.trim();
        // Verify the address
        if (!strTo || strTo.length !== 34 || !strTo.startsWith("s")) {
          return M.toast({html: 'Please enter a valid address!', displayLength: 2000});
        }
        // Prepare wallet data
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const strPrivkey = WALLET.getActiveWallet().getPrivkey();
        // Construct the transaction
        const cTx = WALLET.sccjs.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnode ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? 'id' + cSelectedNFT.collectionIndex : cSelectedNFT.collection;
        cTx.addoutputburn(0.00000001, idContract + ' transfer ' + strTo + ' ' + cSelectedNFT.nft);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            M.toast({html: 'NFT Sent!', displayLength: 3000});
            cUTXO.spent = true;
            getUnspentTransactions();
            // Move user back to their NFTs page
            switchToViewCollection();
            renderNFTs();
          });
        });
      }

      function burnNftGUI() {
        // Prepare wallet data
        const strAddr = WALLET.getActiveWallet().getPubkey();
        const strPrivkey = WALLET.getActiveWallet().getPrivkey();
        // Construct the transaction
        const cTx = WALLET.sccjs.tx.transaction();
        // Add input
        const cUTXO = WALLET.getCoinsToSpend(2000, true, strAddr)[0];
        if (!cUTXO) return M.toast({html: 'You don\'t have enough SCC for gas fees!', displayLength: 3000});
        cTx.addinput(cUTXO.id, cUTXO.vout, cUTXO.script);
        // SCP output
        const fIndexed = UPGRADES.isTokenIndexingActive(isFullnode ? nCacheHeight : cachedBlockCount);
        const idContract = fIndexed ? 'id' + cSelectedNFT.collectionIndex : cSelectedNFT.collection;
        cTx.addoutputburn(0.00000001, idContract + ' destroy ' + cSelectedNFT.nft);
        // Fee & Change output
        const nFee = WALLET.getFee(cTx.serialize().length);
        const nChange = ((cUTXO.sats / COIN) - nFee).toFixed(8);
        cTx.addoutput(strAddr, nChange);
        // Broadcast
        cTx.sign(WALLET.getActiveWallet().getPrivkey(), 1).then(strSignedTx => {
          WALLET.broadcastTx(strSignedTx).then(strTXID => {
            M.toast({html: 'NFT Burned!', displayLength: 3000});
            cUTXO.spent = true;
            getUnspentTransactions();
            // Move user back to their NFTs page
            switchToViewCollection();
            renderNFTs();
          });
        });
      }
    </script>

    <div class="modal fade" id="sendNftModal" tabindex="-1" aria-labelledby="sendNftModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="sendNftModalLabel">Send your NFT</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="col-md" style="margin: 20px 0;">
              <div class="omrs-input-group" style="width:100%;">
                <label class="omrs-input-underlined">
                  <input required id="sendAddressNft" style="text-align: center;" type="text">
                  <span class="omrs-input-label">Recipient Address</span>
                </label>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal" onclick="sendNftGUI()">Send</button>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="burnNftModal" tabindex="-1" aria-labelledby="burnNftModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="burnNftModalLabel">Burn your NFT</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="col-md" style="margin: 20px 0;text-align: center;">
              <h5 style="font-weight: bold; ">Are you sure you want to burn your NFT?</h5>
              <p>This action is irreversible! </p>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-danger" data-bs-dismiss="modal" onclick="burnNftGUI()">Burn</button>
          </div>
        </div>
      </div>
    </div>



    <i id="themeButton" onclick="loadNextTheme();" class="fas fa-sun" style="position: fixed; bottom: 10px; left: 10px; color: black; opacity: 0.5; cursor: pointer;"></i>
  </main>

  <!-- Materialize Library -->
  <script type="text/javascript" src="js/materialize.js"></script>
  <script src="js/bootstrap.bundle.min.js"></script>
  <script src="js/select.js"></script>

</body>

</html>